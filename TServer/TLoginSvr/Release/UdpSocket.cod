; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\UdpSocket.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_07PFKAHOIJ@SUCCESS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FPDOAGBG@NOUSER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JHHLKDOI@DUPLICATE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07NCHCCDCP@VERSION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MLFDIMPC@INTERNAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DDIIKNEP@BLOCK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PCGPODPE@IPBLOCK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PHMBJHPL@NEEDAGREEMENT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LHGNKMLN@NEEDWORLDUNIFY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FHLMKKMC@NOGROUP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HLEOFOMF@DUPNAME?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OADFMIBC@INVALIDSLOT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DIAPIBEN@PROTECTED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GEMHKEIO@OVERCHAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KHBKMNCB@GUILD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKJOGMGF@SUCCESS?5?$CFs?3?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OANKDHFI@NOSERVER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CUdpSocket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUdpSocket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialize@CUdpSocket@@QAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LogLogin@CUdpSocket@@QAEXPAVCTUser@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LogCharCreate@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LogCharDelete@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LogGameStart@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@PADGE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@GIG@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagTCASHITEMSALE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagTCASHITEMSALE@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagTCASHITEMSALE@@IU1@V?$allocator@UtagTCASHITEMSALE@@@std@@@std@@YAXPAUtagTCASHITEMSALE@@IABU1@AAV?$allocator@UtagTCASHITEMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagMONREGEN@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagMONREGEN@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagMONREGEN@@IU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAXPAUtagMONREGEN@@IABU1@AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagLOTTERY@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagLOTTERY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagLOTTERY@@IU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAXPAUtagLOTTERY@@IABU1@AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@GV?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagTCASHITEMSALE@@V?$allocator@UtagTCASHITEMSALE@@@std@@@std@@YAXPAUtagTCASHITEMSALE@@0AAV?$allocator@UtagTCASHITEMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagTCASHITEMSALE@@PAU1@V?$allocator@UtagTCASHITEMSALE@@@std@@@std@@YAPAUtagTCASHITEMSALE@@PAU1@00AAV?$allocator@UtagTCASHITEMSALE@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagTCASHITEMSALE@@PAU1@@std@@YAPAUtagTCASHITEMSALE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagMONREGEN@@V?$allocator@UtagMONREGEN@@@std@@@std@@YAXPAUtagMONREGEN@@0AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagMONREGEN@@PAU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAPAUtagMONREGEN@@PAU1@00AAV?$allocator@UtagMONREGEN@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagMONREGEN@@PAU1@@std@@YAPAUtagMONREGEN@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagLOTTERY@@V?$allocator@UtagLOTTERY@@@std@@@std@@YAXPAUtagLOTTERY@@0AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagLOTTERY@@PAU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAPAUtagLOTTERY@@PAU1@00AAV?$allocator@UtagLOTTERY@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagLOTTERY@@PAU1@@std@@YAPAUtagLOTTERY@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagTCASHITEMSALE@@@std@@QAEXPAUtagTCASHITEMSALE@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagTCASHITEMSALE@@@std@@QAEXPAUtagTCASHITEMSALE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagMONREGEN@@@std@@QAEXPAUtagMONREGEN@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagMONREGEN@@@std@@QAEXPAUtagMONREGEN@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagLOTTERY@@@std@@QAEXPAUtagLOTTERY@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagLOTTERY@@@std@@QAEXPAUtagLOTTERY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAGIG@std@@YAXPAGIABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@GG@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagTCASHITEMSALE@@PAU1@V?$allocator@UtagTCASHITEMSALE@@@std@@@std@@YAPAUtagTCASHITEMSALE@@PAU1@00AAV?$allocator@UtagTCASHITEMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagMONREGEN@@PAU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAPAUtagMONREGEN@@PAU1@00AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagLOTTERY@@PAU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAPAUtagLOTTERY@@PAU1@00AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagTCASHITEMSALE@@U1@@std@@YAXPAUtagTCASHITEMSALE@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagTCASHITEMSALE@@@std@@YAXPAUtagTCASHITEMSALE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagMONREGEN@@U1@@std@@YAXPAUtagMONREGEN@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagMONREGEN@@@std@@YAXPAUtagMONREGEN@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagLOTTERY@@U1@@std@@YAXPAUtagLOTTERY@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagLOTTERY@@@std@@YAXPAUtagLOTTERY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CLOSESOCKET@CUdpSocket@@AAEXAAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CUdpSocket@@QAE@XZ				; CUdpSocket::CUdpSocket
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:NEAR
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
;	COMDAT ??0CUdpSocket@@QAE@XZ
_TEXT	SEGMENT
??0CUdpSocket@@QAE@XZ PROC NEAR				; CUdpSocket::CUdpSocket, COMDAT
; _this$ = ecx

; 12   : {

  00000	56		 push	 esi

; 13   : 	m_lpLogBuf  = new char [sizeof(_UDPPACKET)+1] ;

  00001	68 25 04 00 00	 push	 1061			; 00000425H
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0000d	83 c4 04	 add	 esp, 4
  00010	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 14   : 
; 15   : 	InitializeCriticalSectionAndSpinCount(&m_LogLock, 4000);

  00013	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  00018	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 16   : }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??0CUdpSocket@@QAE@XZ ENDP				; CUdpSocket::CUdpSocket
_TEXT	ENDS
PUBLIC	?Initialize@CUdpSocket@@QAEHPADH@Z		; CUdpSocket::Initialize
EXTRN	__imp__WSASocketA@24:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__inet_addr@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Initialize@CUdpSocket@@QAEHPADH@Z
_TEXT	SEGMENT
_pIPAddr$ = 8						; size = 4
_pPort$ = 12						; size = 4
?Initialize@CUdpSocket@@QAEHPADH@Z PROC NEAR		; CUdpSocket::Initialize, COMDAT
; _this$ = ecx

; 31   : {

  00000	56		 push	 esi

; 32   : 
; 33   : 	m_SendSock = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, 0, 0);

  00001	6a 00		 push	 0
  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 11		 push	 17			; 00000011H
  00009	6a 02		 push	 2
  0000b	6a 02		 push	 2
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24

; 34   : 
; 35   : 	if(INVALID_SOCKET == m_SendSock )

  00015	83 f8 ff	 cmp	 eax, -1
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	75 06		 jne	 SHORT $L104963

; 36   : 	{
; 37   : 		return FALSE;

  0001c	33 c0		 xor	 eax, eax
  0001e	5e		 pop	 esi

; 45   : }

  0001f	c2 08 00	 ret	 8
$L104963:

; 38   : 	}
; 39   : 
; 40   : 	m_LogAddr.sin_family		= AF_INET;
; 41   : 	m_LogAddr.sin_port			= htons(pPort);

  00022	8b 44 24 0c	 mov	 eax, DWORD PTR _pPort$[esp]
  00026	50		 push	 eax
  00027	66 c7 46 04 02
	00		 mov	 WORD PTR [esi+4], 2
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 42   : 	m_LogAddr.sin_addr.s_addr	= inet_addr(pIPAddr);

  00033	8b 4c 24 08	 mov	 ecx, DWORD PTR _pIPAddr$[esp]
  00037	51		 push	 ecx
  00038	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 43   : 
; 44   : 	return TRUE;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	5e		 pop	 esi

; 45   : }

  0004b	c2 08 00	 ret	 8
?Initialize@CUdpSocket@@QAEHPADH@Z ENDP			; CUdpSocket::Initialize
_TEXT	ENDS
PUBLIC	?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z ; CUdpSocket::SendToLogPacket
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
EXTRN	__imp__sendto@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z
_TEXT	SEGMENT
tv128 = -4						; size = 4
_pUdpPacket$ = 8					; size = 4
?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z PROC NEAR ; CUdpSocket::SendToLogPacket, COMDAT
; _this$ = ecx

; 52   : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	8b d9		 mov	 ebx, ecx

; 53   : 	
; 54   : 	EnterCriticalSection(&m_LogLock);

  00006	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	89 44 24 14	 mov	 DWORD PTR tv128[esp+24], eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 55   : 
; 56   : 		memcpy(m_lpLogBuf, pUdpPacket, sizeof(_UDPPACKET));

  00015	8b 6c 24 18	 mov	 ebp, DWORD PTR _pUdpPacket$[esp+16]
  00019	8b 7b 2c	 mov	 edi, DWORD PTR [ebx+44]

; 57   : 
; 58   : 		int nSendByte = sendto(m_SendSock, (char*)pUdpPacket, pUdpPacket->dwSize, 0, (SOCKADDR *)&m_LogAddr, sizeof(m_LogAddr));

  0001c	6a 10		 push	 16			; 00000010H
  0001e	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  00023	8b f5		 mov	 esi, ebp
  00025	f3 a5		 rep movsd
  00027	0f b7 4d 00	 movzx	 ecx, WORD PTR [ebp]
  0002b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0002d	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00030	50		 push	 eax
  00031	6a 00		 push	 0
  00033	51		 push	 ecx
  00034	55		 push	 ebp
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sendto@24

; 59   : 
; 60   : 		if(SOCKET_ERROR == nSendByte) 
; 61   : 		{
; 62   : 			//
; 63   : 			//	Mr Park Add Log
; 64   : 			//
; 65   : 			//	LogEvent("(X) UDP sendto failed with error");
; 66   : 			//
; 67   : 		}
; 68   : 
; 69   : 	LeaveCriticalSection(&m_LogLock);

  0003c	8b 44 24 10	 mov	 eax, DWORD PTR tv128[esp+20]
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 70   : 
; 71   : 	if(pUdpPacket) 
; 72   : 	{
; 73   : 		delete pUdpPacket;

  00047	55		 push	 ebp
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	5b		 pop	 ebx

; 74   : 		pUdpPacket	= 0x00;
; 75   : 	}
; 76   : }

  00054	59		 pop	 ecx
  00055	c2 04 00	 ret	 4
?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z ENDP	; CUdpSocket::SendToLogPacket
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC NEAR			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 149  : {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _time$[esp]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _time$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 150  : }

  0000f	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	?CLOSESOCKET@CUdpSocket@@AAEXAAI@Z		; CUdpSocket::CLOSESOCKET
EXTRN	__imp__closesocket@4:NEAR
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.h
;	COMDAT ?CLOSESOCKET@CUdpSocket@@AAEXAAI@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?CLOSESOCKET@CUdpSocket@@AAEXAAI@Z PROC NEAR		; CUdpSocket::CLOSESOCKET, COMDAT
; _this$ = ecx

; 29   : 	VOID CLOSESOCKET( SOCKET &x )	{	if(x != INVALID_SOCKET) closesocket(x), x = INVALID_SOCKET; }

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _x$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	83 f8 ff	 cmp	 eax, -1
  0000a	74 0d		 je	 SHORT $L101876
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00013	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$L101876:
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
?CLOSESOCKET@CUdpSocket@@AAEXAAI@Z ENDP			; CUdpSocket::CLOSESOCKET
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 379  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	??1CUdpSocket@@QAE@XZ				; CUdpSocket::~CUdpSocket
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
;	COMDAT ??1CUdpSocket@@QAE@XZ
_TEXT	SEGMENT
??1CUdpSocket@@QAE@XZ PROC NEAR				; CUdpSocket::~CUdpSocket, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 20   : 	CLOSESOCKET(m_SendSock);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 f8 ff	 cmp	 eax, -1
  00008	74 0d		 je	 SHORT $L105563
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00011	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$L105563:

; 21   : 
; 22   : 	delete m_lpLogBuf;

  00017	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4

; 23   : 
; 24   : 	DeleteCriticalSection(&m_LogLock);

  00023	83 c6 14	 add	 esi, 20			; 00000014H
  00026	56		 push	 esi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0002d	5e		 pop	 esi

; 25   : }

  0002e	c3		 ret	 0
??1CUdpSocket@@QAE@XZ ENDP				; CUdpSocket::~CUdpSocket
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:NEAR
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC NEAR		; ATL::CTime::GetTickCount, COMDAT

; 139  : 	return( CTime( ::_time64( NULL ) ) );

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[esp]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	83 c4 04	 add	 esp, 4
  00010	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00013	8b c1		 mov	 eax, ecx

; 140  : }

  00015	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z		; CUdpSocket::Log
EXTRN	?GetAsDBTIMESTAMP@CTime@ATL@@QBE_NAAUtagDBTIMESTAMP@@@Z:NEAR ; ATL::CTime::GetAsDBTIMESTAMP
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
;	COMDAT ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z
_TEXT	SEGMENT
_tNowTime$ = -8						; size = 8
_pUDPPacket$ = 8					; size = 4
_pLogSize$ = 12						; size = 4
?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z PROC NEAR	; CUdpSocket::Log, COMDAT
; _this$ = ecx

; 82   : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi

; 83   : 	_LPLOG_DATA_ pLogData = (_LPLOG_DATA_)pUDPPacket->szPacket;	
; 84   : 
; 85   : 	//	Set Current Time
; 86   : 	CTime tNowTime = CTime::GetCurrentTime();

  00005	6a 00		 push	 0
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 __time64
  0000e	8b 74 24 18	 mov	 esi, DWORD PTR _pUDPPacket$[esp+16]
  00012	89 44 24 0c	 mov	 DWORD PTR _tNowTime$[esp+20], eax
  00016	83 c4 04	 add	 esp, 4
  00019	8d 46 24	 lea	 eax, DWORD PTR [esi+36]

; 87   : 	tNowTime.GetAsDBTIMESTAMP( pLogData->tTimeStamp );

  0001c	50		 push	 eax
  0001d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _tNowTime$[esp+20]
  00021	89 54 24 10	 mov	 DWORD PTR _tNowTime$[esp+24], edx
  00025	e8 00 00 00 00	 call	 ?GetAsDBTIMESTAMP@CTime@ATL@@QBE_NAAUtagDBTIMESTAMP@@@Z ; ATL::CTime::GetAsDBTIMESTAMP

; 88   : 
; 89   : 	//	Command & Size
; 90   : 	pUDPPacket->dwCommand	= LP_LOG;
; 91   : 	pUDPPacket->dwSize		= sizeof(_UDPPACKET) - sizeof(pUDPPacket->szPacket ) + sizeof(_LOG_DATA_) - sizeof(pLogData->szLog) + pLogSize;

  0002a	8b 4c 24 18	 mov	 ecx, DWORD PTR _pLogSize$[esp+12]
  0002e	81 c1 1c 02 00
	00		 add	 ecx, 540		; 0000021cH
  00034	66 89 0e	 mov	 WORD PTR [esi], cx

; 92   : 
; 93   : 	SendToLogPacket(pUDPPacket);

  00037	56		 push	 esi
  00038	8b cf		 mov	 ecx, edi
  0003a	66 c7 46 02 00
	00		 mov	 WORD PTR [esi+2], 0
  00040	e8 00 00 00 00	 call	 ?SendToLogPacket@CUdpSocket@@QAEXPAU_UDPPACKET@@@Z ; CUdpSocket::SendToLogPacket
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 94   : }

  00047	83 c4 08	 add	 esp, 8
  0004a	c2 08 00	 ret	 8
?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z ENDP		; CUdpSocket::Log
_TEXT	ENDS
PUBLIC	?LogLogin@CUdpSocket@@QAEXPAVCTUser@@K@Z	; CUdpSocket::LogLogin
PUBLIC	??_C@_07PFKAHOIJ@SUCCESS?$AA@			; `string'
PUBLIC	??_C@_06FPDOAGBG@NOUSER?$AA@			; `string'
PUBLIC	??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@		; `string'
PUBLIC	??_C@_09JHHLKDOI@DUPLICATE?$AA@			; `string'
PUBLIC	??_C@_07NCHCCDCP@VERSION?$AA@			; `string'
PUBLIC	??_C@_08MLFDIMPC@INTERNAL?$AA@			; `string'
PUBLIC	??_C@_05DDIIKNEP@BLOCK?$AA@			; `string'
PUBLIC	??_C@_07PCGPODPE@IPBLOCK?$AA@			; `string'
PUBLIC	??_C@_0O@PHMBJHPL@NEEDAGREEMENT?$AA@		; `string'
PUBLIC	??_C@_0P@LHGNKMLN@NEEDWORLDUNIFY?$AA@		; `string'
EXTRN	__imp__lstrcpyA@8:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	__imp__inet_ntoa@4:NEAR
;	COMDAT ??_C@_07PFKAHOIJ@SUCCESS?$AA@
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_07PFKAHOIJ@SUCCESS?$AA@ DB 'SUCCESS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPDOAGBG@NOUSER?$AA@
CONST	SEGMENT
??_C@_06FPDOAGBG@NOUSER?$AA@ DB 'NOUSER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@
CONST	SEGMENT
??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@ DB 'INVALIDPASSWD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHHLKDOI@DUPLICATE?$AA@
CONST	SEGMENT
??_C@_09JHHLKDOI@DUPLICATE?$AA@ DB 'DUPLICATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCHCCDCP@VERSION?$AA@
CONST	SEGMENT
??_C@_07NCHCCDCP@VERSION?$AA@ DB 'VERSION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLFDIMPC@INTERNAL?$AA@
CONST	SEGMENT
??_C@_08MLFDIMPC@INTERNAL?$AA@ DB 'INTERNAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDIIKNEP@BLOCK?$AA@
CONST	SEGMENT
??_C@_05DDIIKNEP@BLOCK?$AA@ DB 'BLOCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCGPODPE@IPBLOCK?$AA@
CONST	SEGMENT
??_C@_07PCGPODPE@IPBLOCK?$AA@ DB 'IPBLOCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PHMBJHPL@NEEDAGREEMENT?$AA@
CONST	SEGMENT
??_C@_0O@PHMBJHPL@NEEDAGREEMENT?$AA@ DB 'NEEDAGREEMENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LHGNKMLN@NEEDWORLDUNIFY?$AA@
CONST	SEGMENT
??_C@_0P@LHGNKMLN@NEEDWORLDUNIFY?$AA@ DB 'NEEDWORLDUNIFY', 00H ; `string'
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
CONST	ENDS
;	COMDAT ?LogLogin@CUdpSocket@@QAEXPAVCTUser@@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pUser$ = 8						; size = 4
_pReturnCode$ = 12					; size = 4
?LogLogin@CUdpSocket@@QAEXPAVCTUser@@K@Z PROC NEAR	; CUdpSocket::LogLogin, COMDAT
; _this$ = ecx

; 101  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 102  : 	if(!pUser) return;

  00002	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pUser$[esp+4]
  00006	85 db		 test	 ebx, ebx
  00008	89 4c 24 04	 mov	 DWORD PTR _this$[esp+8], ecx
  0000c	0f 84 01 01 00
	00		 je	 $L104990
  00012	56		 push	 esi
  00013	57		 push	 edi

; 103  : 
; 104  : 	_LPUDPPACKET pUDPPacket = new _UDPPACKET;

  00014	68 24 04 00 00	 push	 1060			; 00000424H
  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	8b f0		 mov	 esi, eax

; 105  : 	memset( pUDPPacket, 0x00, sizeof(_UDPPACKET));

  00020	33 c0		 xor	 eax, eax
  00022	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  00027	8b fe		 mov	 edi, esi
  00029	f3 ab		 rep stosd

; 106  : 
; 107  : 	_LPLOG_DATA_ pLogData = (_LPLOG_DATA_)pUDPPacket->szPacket;
; 108  :     
; 109  : 
; 110  : 	pLogData->dwAction	=	LOGLOGIN_LOGIN;	

  0002b	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 111  : 	lstrcpy( pLogData->szClientIP, inet_ntoa(pUser->m_addr.sin_addr));

  0002e	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  0003b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcpyA@8
  00041	50		 push	 eax
  00042	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00045	51		 push	 ecx
  00046	ff d7		 call	 edi

; 112  : 
; 113  : 	pLogData->dwKey[0]	=	pUser->m_dwID;

  00048	8b 93 04 01 01
	00		 mov	 edx, DWORD PTR [ebx+65796]
  0004e	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00051	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 114  : 	lstrcpy( pLogData->szKey[0], pUser->m_strUserID );

  00058	8b 83 fc 00 01
	00		 mov	 eax, DWORD PTR [ebx+65788]
  0005e	50		 push	 eax
  0005f	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00065	51		 push	 ecx
  00066	ff d7		 call	 edi

; 115  : 
; 116  : 	switch(pReturnCode)

  00068	8b 44 24 18	 mov	 eax, DWORD PTR _pReturnCode$[esp+12]
  0006c	83 f8 09	 cmp	 eax, 9
  0006f	77 7e		 ja	 SHORT $L104999
  00071	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L105593[eax*4]
$L105002:

; 117  : 	{
; 118  : 	case LR_SUCCESS:		lstrcpy(pLogData->szKey[4], "SUCCESS");			break;

  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PFKAHOIJ@SUCCESS?$AA@
  0007d	eb 67		 jmp	 SHORT $L105591
$L105004:

; 119  : 	case LR_NOUSER:			lstrcpy(pLogData->szKey[4], "NOUSER");			break;

  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06FPDOAGBG@NOUSER?$AA@
  00084	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  0008a	50		 push	 eax
  0008b	eb 60		 jmp	 SHORT $L105592
$L105006:

; 120  : 	case LR_INVALIDPASSWD:	lstrcpy(pLogData->szKey[4], "INVALIDPASSWD");	break;

  0008d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@
  00092	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  00098	51		 push	 ecx
  00099	eb 52		 jmp	 SHORT $L105592
$L105008:

; 121  : 	case LR_DUPLICATE:		lstrcpy(pLogData->szKey[4], "DUPLICATE");		break;

  0009b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09JHHLKDOI@DUPLICATE?$AA@
  000a0	eb 44		 jmp	 SHORT $L105591
$L105010:

; 122  : 	case LR_VERSION:		lstrcpy(pLogData->szKey[4], "VERSION");			break;	

  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07NCHCCDCP@VERSION?$AA@
  000a7	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  000ad	50		 push	 eax
  000ae	eb 3d		 jmp	 SHORT $L105592
$L105012:

; 123  : 	case LR_INTERNAL:		lstrcpy(pLogData->szKey[4], "INTERNAL");		break;	

  000b0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MLFDIMPC@INTERNAL?$AA@
  000b5	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  000bb	51		 push	 ecx
  000bc	eb 2f		 jmp	 SHORT $L105592
$L105014:

; 124  : 	case LR_BLOCK:			lstrcpy(pLogData->szKey[4], "BLOCK");			break;	

  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DDIIKNEP@BLOCK?$AA@
  000c3	eb 21		 jmp	 SHORT $L105591
$L105016:

; 125  : 	case LR_IPBLOCK:		lstrcpy(pLogData->szKey[4], "IPBLOCK");			break;

  000c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PCGPODPE@IPBLOCK?$AA@
  000ca	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  000d0	50		 push	 eax
  000d1	eb 1a		 jmp	 SHORT $L105592
$L105018:

; 126  : 	case LR_NEEDAGREEMENT:	lstrcpy(pLogData->szKey[4], "NEEDAGREEMENT");	break;

  000d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@PHMBJHPL@NEEDAGREEMENT?$AA@
  000d8	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  000de	51		 push	 ecx
  000df	eb 0c		 jmp	 SHORT $L105592
$L105020:

; 127  : 	case LR_NEEDWORLDUNIFY:	lstrcpy(pLogData->szKey[4], "NEEDWORLDUNIFY");	break;

  000e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@LHGNKMLN@NEEDWORLDUNIFY?$AA@
$L105591:
  000e6	8d 96 7c 01 00
	00		 lea	 edx, DWORD PTR [esi+380]
  000ec	52		 push	 edx
$L105592:
  000ed	ff d7		 call	 edi
$L104999:

; 128  : 	}
; 129  : 
; 130  : 	pLogData->dwFormat = LF_TEXT;
; 131  : 
; 132  : 	Log( pUDPPacket, lstrlen(pLogData->szLog));

  000ef	8d 86 18 02 00
	00		 lea	 eax, DWORD PTR [esi+536]
  000f5	50		 push	 eax
  000f6	c7 86 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+532], 0
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  00106	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  0010a	50		 push	 eax
  0010b	56		 push	 esi
  0010c	e8 00 00 00 00	 call	 ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z ; CUdpSocket::Log
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
$L104990:
  00113	5b		 pop	 ebx

; 133  : }

  00114	59		 pop	 ecx
  00115	c2 08 00	 ret	 8
$L105593:
  00118	00 00 00 00	 DD	 $L105002
  0011c	00 00 00 00	 DD	 $L105004
  00120	00 00 00 00	 DD	 $L105006
  00124	00 00 00 00	 DD	 $L105008
  00128	00 00 00 00	 DD	 $L105010
  0012c	00 00 00 00	 DD	 $L105012
  00130	00 00 00 00	 DD	 $L105014
  00134	00 00 00 00	 DD	 $L105016
  00138	00 00 00 00	 DD	 $L105018
  0013c	00 00 00 00	 DD	 $L105020
?LogLogin@CUdpSocket@@QAEXPAVCTUser@@K@Z ENDP		; CUdpSocket::LogLogin
_TEXT	ENDS
PUBLIC	?LogCharCreate@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z ; CUdpSocket::LogCharCreate
PUBLIC	??_C@_07FHLMKKMC@NOGROUP?$AA@			; `string'
PUBLIC	??_C@_07HLEOFOMF@DUPNAME?$AA@			; `string'
PUBLIC	??_C@_0M@OADFMIBC@INVALIDSLOT?$AA@		; `string'
PUBLIC	??_C@_09DIAPIBEN@PROTECTED?$AA@			; `string'
PUBLIC	??_C@_08GEMHKEIO@OVERCHAR?$AA@			; `string'
;	COMDAT ??_C@_07FHLMKKMC@NOGROUP?$AA@
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_07FHLMKKMC@NOGROUP?$AA@ DB 'NOGROUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HLEOFOMF@DUPNAME?$AA@
CONST	SEGMENT
??_C@_07HLEOFOMF@DUPNAME?$AA@ DB 'DUPNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OADFMIBC@INVALIDSLOT?$AA@
CONST	SEGMENT
??_C@_0M@OADFMIBC@INVALIDSLOT?$AA@ DB 'INVALIDSLOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DIAPIBEN@PROTECTED?$AA@
CONST	SEGMENT
??_C@_09DIAPIBEN@PROTECTED?$AA@ DB 'PROTECTED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GEMHKEIO@OVERCHAR?$AA@
CONST	SEGMENT
??_C@_08GEMHKEIO@OVERCHAR?$AA@ DB 'OVERCHAR', 00H	; `string'
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
CONST	ENDS
;	COMDAT ?LogCharCreate@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pUser$ = 8						; size = 4
_pReturnCode$ = 12					; size = 4
_pGroupID$ = 16						; size = 1
_pChar$ = 20						; size = 4
?LogCharCreate@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z PROC NEAR ; CUdpSocket::LogCharCreate, COMDAT
; _this$ = ecx

; 139  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 140  : 	if(!pUser || !pChar ) return;

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pUser$[esp+4]
  00006	85 ed		 test	 ebp, ebp
  00008	89 4c 24 04	 mov	 DWORD PTR _this$[esp+8], ecx
  0000c	0f 84 b8 01 00
	00		 je	 $L105030
  00012	53		 push	 ebx
  00013	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pChar$[esp+8]
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 aa 01 00
	00		 je	 $L105610
  0001f	56		 push	 esi
  00020	57		 push	 edi

; 141  : 
; 142  : 	_LPUDPPACKET pUDPPacket = new _UDPPACKET;

  00021	68 24 04 00 00	 push	 1060			; 00000424H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b f0		 mov	 esi, eax

; 143  : 	memset( pUDPPacket, 0x00, sizeof(_UDPPACKET));

  0002d	33 c0		 xor	 eax, eax
  0002f	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  00034	8b fe		 mov	 edi, esi
  00036	f3 ab		 rep stosd

; 144  : 	_LPLOG_DATA_ pLogData = (_LPLOG_DATA_)pUDPPacket->szPacket;
; 145  : 
; 146  : 
; 147  : 	pLogData->dwAction		=	LOGLOGIN_CHARCREATE;	
; 148  : 	pLogData->dwServerID	=	pGroupID;

  00038	0f b6 44 24 24	 movzx	 eax, BYTE PTR _pGroupID$[esp+20]
  0003d	c7 46 48 04 00
	00 00		 mov	 DWORD PTR [esi+72], 4
  00044	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 149  : 	
; 150  : 	lstrcpy( pLogData->szClientIP, inet_ntoa(pUser->m_addr.sin_addr));

  00047	8b 4d 40	 mov	 ecx, DWORD PTR [ebp+64]
  0004a	83 c4 04	 add	 esp, 4
  0004d	51		 push	 ecx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00054	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcpyA@8
  0005a	50		 push	 eax
  0005b	8d 56 38	 lea	 edx, DWORD PTR [esi+56]
  0005e	52		 push	 edx
  0005f	ff d7		 call	 edi

; 151  : 
; 152  : 	pLogData->dwKey[0]	=	pUser->m_dwID;

  00061	8b 85 04 01 01
	00		 mov	 eax, DWORD PTR [ebp+65796]
  00067	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0006a	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 153  : 	lstrcpy( pLogData->szKey[0], pUser->m_strUserID);

  00071	8b 8d fc 00 01
	00		 mov	 ecx, DWORD PTR [ebp+65788]
  00077	51		 push	 ecx
  00078	8d 96 b4 00 00
	00		 lea	 edx, DWORD PTR [esi+180]
  0007e	52		 push	 edx
  0007f	ff d7		 call	 edi

; 154  : 
; 155  : 
; 156  : 	lstrcpy( pLogData->szKey[1], pChar->m_strName);

  00081	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00084	50		 push	 eax
  00085	8d 8e e6 00 00
	00		 lea	 ecx, DWORD PTR [esi+230]
  0008b	51		 push	 ecx
  0008c	ff d7		 call	 edi

; 157  : 
; 158  : 	pLogData->dwKey[3]	=	pChar->m_bRace;

  0008e	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  00092	99		 cdq
  00093	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00096	89 56 78	 mov	 DWORD PTR [esi+120], edx

; 159  : 	pLogData->dwKey[5]	=	pChar->m_bClass;

  00099	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  0009d	99		 cdq
  0009e	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000a4	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx

; 160  : 
; 161  : 	pLogData->dwKey[9]	=	pChar->m_bCountry;

  000aa	0f b6 43 0d	 movzx	 eax, BYTE PTR [ebx+13]
  000ae	99		 cdq
  000af	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  000b5	89 96 a8 00 00
	00		 mov	 DWORD PTR [esi+168], edx

; 162  : 	pLogData->dwKey[10]	=	pChar->m_bLevel;

  000bb	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  000bf	99		 cdq
  000c0	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax

; 163  :     
; 164  : 	switch(pReturnCode)

  000c6	8b 44 24 1c	 mov	 eax, DWORD PTR _pReturnCode$[esp+16]
  000ca	83 f8 07	 cmp	 eax, 7
  000cd	89 96 b0 00 00
	00		 mov	 DWORD PTR [esi+176], edx
  000d3	77 5b		 ja	 SHORT $L105038
  000d5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L105613[eax*4]
$L105041:

; 165  : 	{
; 166  : 	case CR_SUCCESS:		lstrcpy( pLogData->szKey[4], "SUCCESS");	break;

  000dc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PFKAHOIJ@SUCCESS?$AA@
  000e1	eb 44		 jmp	 SHORT $L105611
$L105042:

; 167  : 	case CR_NOGROUP:		lstrcpy( pLogData->szKey[4], "NOGROUP");	break;

  000e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FHLMKKMC@NOGROUP?$AA@
  000e8	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  000ee	50		 push	 eax
  000ef	eb 3d		 jmp	 SHORT $L105612
$L105044:

; 168  : 	case CR_DUPNAME:		lstrcpy( pLogData->szKey[4], "DUPNAME");	break;

  000f1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07HLEOFOMF@DUPNAME?$AA@
  000f6	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  000fc	51		 push	 ecx
  000fd	eb 2f		 jmp	 SHORT $L105612
$L105046:

; 169  : 	case CR_INVALIDSLOT:	lstrcpy( pLogData->szKey[4], "INVALIDSLOT");break;

  000ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@OADFMIBC@INVALIDSLOT?$AA@
  00104	eb 21		 jmp	 SHORT $L105611
$L105048:

; 170  : 	case CR_PROTECTED:		lstrcpy( pLogData->szKey[4], "PROTECTED");	break;	

  00106	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09DIAPIBEN@PROTECTED?$AA@
  0010b	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  00111	50		 push	 eax
  00112	eb 1a		 jmp	 SHORT $L105612
$L105050:

; 171  : 	case CR_OVERCHAR:		lstrcpy( pLogData->szKey[4], "OVERCHAR");	break;

  00114	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GEMHKEIO@OVERCHAR?$AA@
  00119	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  0011f	51		 push	 ecx
  00120	eb 0c		 jmp	 SHORT $L105612
$L105052:

; 172  : 	case CR_INTERNAL:		lstrcpy( pLogData->szKey[4], "INTERNAL");	break;

  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MLFDIMPC@INTERNAL?$AA@
$L105611:
  00127	8d 96 7c 01 00
	00		 lea	 edx, DWORD PTR [esi+380]
  0012d	52		 push	 edx
$L105612:
  0012e	ff d7		 call	 edi
$L105038:

; 173  : 	}
; 174  : 	
; 175  : 	pLogData->dwFormat = LF_CHARBASE;

  00130	c7 86 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+532], 1

; 176  : 
; 177  : 	//	Set the Character Base Information
; 178  : 	_LPLOG_CHARBASE_ pCharBase = (_LPLOG_CHARBASE_)pLogData->szLog;
; 179  : 	
; 180  : 	pCharBase->dwCharID = pChar->m_dwCharID;

  0013a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013c	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax

; 181  : 	lstrcpy( pCharBase->szName, pChar->m_strName);

  00142	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00145	51		 push	 ecx
  00146	8d 96 1c 02 00
	00		 lea	 edx, DWORD PTR [esi+540]
  0014c	52		 push	 edx
  0014d	ff d7		 call	 edi

; 182  : 	pCharBase->bSlot	= pChar->m_bSlot;

  0014f	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  00152	88 86 30 02 00
	00		 mov	 BYTE PTR [esi+560], al

; 183  : 	pCharBase->bLevel	= pChar->m_bLevel;

  00158	8a 4b 0a	 mov	 cl, BYTE PTR [ebx+10]
  0015b	88 8e 31 02 00
	00		 mov	 BYTE PTR [esi+561], cl

; 184  : 	pCharBase->bClass	= pChar->m_bClass;

  00161	8a 53 0b	 mov	 dl, BYTE PTR [ebx+11]
  00164	88 96 32 02 00
	00		 mov	 BYTE PTR [esi+562], dl

; 185  : 	pCharBase->bRace	= pChar->m_bRace;

  0016a	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  0016d	88 86 33 02 00
	00		 mov	 BYTE PTR [esi+563], al

; 186  : 	pCharBase->bCountry	= pChar->m_bCountry;

  00173	8a 4b 0d	 mov	 cl, BYTE PTR [ebx+13]
  00176	88 8e 34 02 00
	00		 mov	 BYTE PTR [esi+564], cl

; 187  : 	pCharBase->bSex		= pChar->m_bSex;

  0017c	8a 53 0e	 mov	 dl, BYTE PTR [ebx+14]
  0017f	88 96 35 02 00
	00		 mov	 BYTE PTR [esi+565], dl

; 188  : 	pCharBase->bHair	= pChar->m_bHair;

  00185	8a 43 0f	 mov	 al, BYTE PTR [ebx+15]
  00188	88 86 36 02 00
	00		 mov	 BYTE PTR [esi+566], al

; 189  : 	pCharBase->bFace	= pChar->m_bFace;

  0018e	8a 4b 10	 mov	 cl, BYTE PTR [ebx+16]
  00191	88 8e 37 02 00
	00		 mov	 BYTE PTR [esi+567], cl

; 190  : 	pCharBase->bBody	= pChar->m_bBody;

  00197	8a 53 11	 mov	 dl, BYTE PTR [ebx+17]
  0019a	88 96 38 02 00
	00		 mov	 BYTE PTR [esi+568], dl

; 191  : 	pCharBase->bPants	= pChar->m_bPants;

  001a0	8a 43 12	 mov	 al, BYTE PTR [ebx+18]
  001a3	88 86 39 02 00
	00		 mov	 BYTE PTR [esi+569], al

; 192  : 	pCharBase->bHand	= pChar->m_bHand;

  001a9	8a 4b 13	 mov	 cl, BYTE PTR [ebx+19]
  001ac	88 8e 3a 02 00
	00		 mov	 BYTE PTR [esi+570], cl

; 193  : 	pCharBase->bFoot	= pChar->m_bFoot;

  001b2	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]

; 194  : 
; 195  : 
; 196  : 	Log( pUDPPacket, sizeof(_LOG_CHARBASE_) );

  001b5	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  001b9	6a 28		 push	 40			; 00000028H
  001bb	56		 push	 esi
  001bc	88 96 3b 02 00
	00		 mov	 BYTE PTR [esi+571], dl
  001c2	e8 00 00 00 00	 call	 ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z ; CUdpSocket::Log
  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
$L105610:
  001c9	5b		 pop	 ebx
$L105030:
  001ca	5d		 pop	 ebp

; 197  : }

  001cb	59		 pop	 ecx
  001cc	c2 10 00	 ret	 16			; 00000010H
  001cf	90		 npad	 1
$L105613:
  001d0	00 00 00 00	 DD	 $L105041
  001d4	00 00 00 00	 DD	 $L105042
  001d8	00 00 00 00	 DD	 $L105044
  001dc	00 00 00 00	 DD	 $L105046
  001e0	00 00 00 00	 DD	 $L105048
  001e4	00 00 00 00	 DD	 $L105050
  001e8	00 00 00 00	 DD	 $L105038
  001ec	00 00 00 00	 DD	 $L105052
?LogCharCreate@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z ENDP ; CUdpSocket::LogCharCreate
_TEXT	ENDS
PUBLIC	?LogCharDelete@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z ; CUdpSocket::LogCharDelete
PUBLIC	??_C@_05KHBKMNCB@GUILD?$AA@			; `string'
;	COMDAT ??_C@_05KHBKMNCB@GUILD?$AA@
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_05KHBKMNCB@GUILD?$AA@ DB 'GUILD', 00H		; `string'
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
CONST	ENDS
;	COMDAT ?LogCharDelete@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pUser$ = 8						; size = 4
_pReturnCode$ = 12					; size = 4
_pGroupID$ = 16						; size = 1
_pChar$ = 20						; size = 4
?LogCharDelete@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z PROC NEAR ; CUdpSocket::LogCharDelete, COMDAT
; _this$ = ecx

; 205  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 206  : 	if(!pUser || !pChar ) return;

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pUser$[esp+4]
  00006	85 ed		 test	 ebp, ebp
  00008	89 4c 24 04	 mov	 DWORD PTR _this$[esp+8], ecx
  0000c	0f 84 b8 01 00
	00		 je	 $L105064
  00012	53		 push	 ebx
  00013	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pChar$[esp+8]
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 aa 01 00
	00		 je	 $L105630
  0001f	56		 push	 esi
  00020	57		 push	 edi

; 207  : 
; 208  : 	_LPUDPPACKET pUDPPacket = new _UDPPACKET;

  00021	68 24 04 00 00	 push	 1060			; 00000424H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b f0		 mov	 esi, eax

; 209  : 	memset( pUDPPacket, 0x00, sizeof(_UDPPACKET));

  0002d	33 c0		 xor	 eax, eax
  0002f	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  00034	8b fe		 mov	 edi, esi
  00036	f3 ab		 rep stosd

; 210  : 	_LPLOG_DATA_ pLogData = (_LPLOG_DATA_)pUDPPacket->szPacket;
; 211  : 
; 212  : 
; 213  : 	pLogData->dwAction	=	LOGLOGIN_CHARDELETE;	
; 214  : 	pLogData->dwServerID	=	pGroupID;

  00038	0f b6 44 24 24	 movzx	 eax, BYTE PTR _pGroupID$[esp+20]
  0003d	c7 46 48 05 00
	00 00		 mov	 DWORD PTR [esi+72], 5
  00044	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 215  : 
; 216  : 
; 217  : 	lstrcpy( pLogData->szClientIP, inet_ntoa(pUser->m_addr.sin_addr));

  00047	8b 4d 40	 mov	 ecx, DWORD PTR [ebp+64]
  0004a	83 c4 04	 add	 esp, 4
  0004d	51		 push	 ecx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00054	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcpyA@8
  0005a	50		 push	 eax
  0005b	8d 56 38	 lea	 edx, DWORD PTR [esi+56]
  0005e	52		 push	 edx
  0005f	ff d7		 call	 edi

; 218  : 
; 219  : 	pLogData->dwKey[0]	=	pUser->m_dwID;

  00061	8b 85 04 01 01
	00		 mov	 eax, DWORD PTR [ebp+65796]
  00067	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0006a	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 220  : 	lstrcpy( pLogData->szKey[0], pUser->m_strUserID);

  00071	8b 8d fc 00 01
	00		 mov	 ecx, DWORD PTR [ebp+65788]
  00077	51		 push	 ecx
  00078	8d 96 b4 00 00
	00		 lea	 edx, DWORD PTR [esi+180]
  0007e	52		 push	 edx
  0007f	ff d7		 call	 edi

; 221  : 
; 222  : 	pLogData->dwKey[1]	= pChar->m_dwCharID;

  00081	8b 03		 mov	 eax, DWORD PTR [ebx]
  00083	89 46 64	 mov	 DWORD PTR [esi+100], eax
  00086	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 223  : 	lstrcpy( pLogData->szKey[1], pChar->m_strName);

  0008d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00090	51		 push	 ecx
  00091	8d 96 e6 00 00
	00		 lea	 edx, DWORD PTR [esi+230]
  00097	52		 push	 edx
  00098	ff d7		 call	 edi

; 224  : 
; 225  : 	pLogData->dwKey[3]	=	pChar->m_bRace;

  0009a	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  0009e	99		 cdq
  0009f	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000a2	89 56 78	 mov	 DWORD PTR [esi+120], edx

; 226  : 	pLogData->dwKey[5]	=	pChar->m_bClass;

  000a5	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  000a9	99		 cdq
  000aa	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000b0	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx

; 227  : 
; 228  : 	pLogData->dwKey[9]	=	pChar->m_bCountry;

  000b6	0f b6 43 0d	 movzx	 eax, BYTE PTR [ebx+13]
  000ba	99		 cdq
  000bb	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  000c1	89 96 a8 00 00
	00		 mov	 DWORD PTR [esi+168], edx

; 229  : 	pLogData->dwKey[10]	=	pChar->m_bLevel;

  000c7	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  000cb	99		 cdq
  000cc	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax

; 230  : 	    
; 231  : 	switch(pReturnCode)

  000d2	8b 44 24 1c	 mov	 eax, DWORD PTR _pReturnCode$[esp+16]
  000d6	83 f8 04	 cmp	 eax, 4
  000d9	89 96 b0 00 00
	00		 mov	 DWORD PTR [esi+176], edx
  000df	77 46		 ja	 SHORT $L105072
  000e1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L105633[eax*4]
$L105075:

; 232  : 	{
; 233  : 	case DR_SUCCESS:		lstrcpy( pLogData->szKey[4], "SUCCESS");		break;

  000e8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07PFKAHOIJ@SUCCESS?$AA@
  000ed	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  000f3	50		 push	 eax
  000f4	eb 2f		 jmp	 SHORT $L105631
$L105076:

; 234  : 	case DR_INVALIDPASSWD:	lstrcpy( pLogData->szKey[4], "INVALIDPASSWD");	break;

  000f6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0O@KFBMCDCJ@INVALIDPASSWD?$AA@
  000fb	eb 21		 jmp	 SHORT $L105632
$L105077:

; 235  : 	case DR_NOGROUP:		lstrcpy( pLogData->szKey[4], "NOGROUP");		break;

  000fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FHLMKKMC@NOGROUP?$AA@
  00102	8d 96 7c 01 00
	00		 lea	 edx, DWORD PTR [esi+380]
  00108	52		 push	 edx
  00109	eb 1a		 jmp	 SHORT $L105631
$L105078:

; 236  : 	case DR_INTERNAL:		lstrcpy( pLogData->szKey[4], "INTERNAL");		break;

  0010b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MLFDIMPC@INTERNAL?$AA@
  00110	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  00116	50		 push	 eax
  00117	eb 0c		 jmp	 SHORT $L105631
$L105079:

; 237  : 	case DR_GUILD:			lstrcpy( pLogData->szKey[4], "GUILD");			break;	

  00119	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05KHBKMNCB@GUILD?$AA@
$L105632:
  0011e	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  00124	51		 push	 ecx
$L105631:
  00125	ff d7		 call	 edi
$L105072:

; 238  : 	}
; 239  : 
; 240  : 	pLogData->dwFormat = LF_CHARBASE;

  00127	c7 86 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+532], 1

; 241  : 
; 242  : 	//	Set the Character Base Information
; 243  : 	_LPLOG_CHARBASE_ pCharBase = (_LPLOG_CHARBASE_)pLogData->szLog;
; 244  : 
; 245  : 	pCharBase->dwCharID = pChar->m_dwCharID;

  00131	8b 13		 mov	 edx, DWORD PTR [ebx]
  00133	89 96 18 02 00
	00		 mov	 DWORD PTR [esi+536], edx

; 246  : 	lstrcpy( pCharBase->szName, pChar->m_strName);

  00139	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0013c	50		 push	 eax
  0013d	8d 8e 1c 02 00
	00		 lea	 ecx, DWORD PTR [esi+540]
  00143	51		 push	 ecx
  00144	ff d7		 call	 edi

; 247  : 
; 248  : 	pCharBase->bSlot	= pChar->m_bSlot;

  00146	8a 53 09	 mov	 dl, BYTE PTR [ebx+9]
  00149	88 96 30 02 00
	00		 mov	 BYTE PTR [esi+560], dl

; 249  : 
; 250  : 	pCharBase->bLevel	= pChar->m_bLevel;

  0014f	8a 43 0a	 mov	 al, BYTE PTR [ebx+10]
  00152	88 86 31 02 00
	00		 mov	 BYTE PTR [esi+561], al

; 251  : 
; 252  : 	pCharBase->bClass	= pChar->m_bClass;

  00158	8a 4b 0b	 mov	 cl, BYTE PTR [ebx+11]
  0015b	88 8e 32 02 00
	00		 mov	 BYTE PTR [esi+562], cl

; 253  : 
; 254  : 	pCharBase->bRace	= pChar->m_bRace;

  00161	8a 53 0c	 mov	 dl, BYTE PTR [ebx+12]
  00164	88 96 33 02 00
	00		 mov	 BYTE PTR [esi+563], dl

; 255  : 	pCharBase->bCountry	= pChar->m_bCountry;

  0016a	8a 43 0d	 mov	 al, BYTE PTR [ebx+13]
  0016d	88 86 34 02 00
	00		 mov	 BYTE PTR [esi+564], al

; 256  : 	pCharBase->bSex		= pChar->m_bSex;

  00173	8a 4b 0e	 mov	 cl, BYTE PTR [ebx+14]
  00176	88 8e 35 02 00
	00		 mov	 BYTE PTR [esi+565], cl

; 257  : 	pCharBase->bHair	= pChar->m_bHair;

  0017c	8a 53 0f	 mov	 dl, BYTE PTR [ebx+15]
  0017f	88 96 36 02 00
	00		 mov	 BYTE PTR [esi+566], dl

; 258  : 	pCharBase->bFace	= pChar->m_bFace;

  00185	8a 43 10	 mov	 al, BYTE PTR [ebx+16]
  00188	88 86 37 02 00
	00		 mov	 BYTE PTR [esi+567], al

; 259  : 	pCharBase->bBody	= pChar->m_bBody;

  0018e	8a 4b 11	 mov	 cl, BYTE PTR [ebx+17]
  00191	88 8e 38 02 00
	00		 mov	 BYTE PTR [esi+568], cl

; 260  : 	pCharBase->bPants	= pChar->m_bPants;

  00197	8a 53 12	 mov	 dl, BYTE PTR [ebx+18]
  0019a	88 96 39 02 00
	00		 mov	 BYTE PTR [esi+569], dl

; 261  : 	pCharBase->bHand	= pChar->m_bHand;

  001a0	8a 43 13	 mov	 al, BYTE PTR [ebx+19]
  001a3	88 86 3a 02 00
	00		 mov	 BYTE PTR [esi+570], al

; 262  : 	pCharBase->bFoot	= pChar->m_bFoot;

  001a9	8a 4b 14	 mov	 cl, BYTE PTR [ebx+20]
  001ac	88 8e 3b 02 00
	00		 mov	 BYTE PTR [esi+571], cl

; 263  : 	
; 264  : 	pCharBase->dwRegion	= pChar->m_dwRegion;

  001b2	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]

; 265  : 
; 266  : 	Log( pUDPPacket, sizeof(_LOG_CHARBASE_) );

  001b5	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  001b9	6a 28		 push	 40			; 00000028H
  001bb	56		 push	 esi
  001bc	89 96 3c 02 00
	00		 mov	 DWORD PTR [esi+572], edx
  001c2	e8 00 00 00 00	 call	 ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z ; CUdpSocket::Log
  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
$L105630:
  001c9	5b		 pop	 ebx
$L105064:
  001ca	5d		 pop	 ebp

; 267  : }

  001cb	59		 pop	 ecx
  001cc	c2 10 00	 ret	 16			; 00000010H
  001cf	90		 npad	 1
$L105633:
  001d0	00 00 00 00	 DD	 $L105075
  001d4	00 00 00 00	 DD	 $L105076
  001d8	00 00 00 00	 DD	 $L105077
  001dc	00 00 00 00	 DD	 $L105078
  001e0	00 00 00 00	 DD	 $L105079
?LogCharDelete@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@@Z ENDP ; CUdpSocket::LogCharDelete
_TEXT	ENDS
PUBLIC	?LogGameStart@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@PADGE@Z ; CUdpSocket::LogGameStart
PUBLIC	??_C@_0BD@FKJOGMGF@SUCCESS?5?$CFs?3?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08OANKDHFI@NOSERVER?$AA@			; `string'
EXTRN	__imp__wsprintfA:NEAR
;	COMDAT ??_C@_0BD@FKJOGMGF@SUCCESS?5?$CFs?3?$CFd?5?$CI?$CFd?$CJ?$AA@
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_0BD@FKJOGMGF@SUCCESS?5?$CFs?3?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'SUCCESS '
	DB	'%s:%d (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OANKDHFI@NOSERVER?$AA@
CONST	SEGMENT
??_C@_08OANKDHFI@NOSERVER?$AA@ DB 'NOSERVER', 00H	; `string'
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tloginsvr\udpsocket.cpp
CONST	ENDS
;	COMDAT ?LogGameStart@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@PADGE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pUser$ = 8						; size = 4
_pReturnCode$ = 12					; size = 4
_pGroupID$ = 16						; size = 1
_pChar$ = 20						; size = 4
_pIP$ = 24						; size = 4
_pPort$ = 28						; size = 2
_pServerID$ = 32					; size = 1
?LogGameStart@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@PADGE@Z PROC NEAR ; CUdpSocket::LogGameStart, COMDAT
; _this$ = ecx

; 274  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 275  : 	if(!pUser || !pChar ) return;

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pUser$[esp+4]
  00006	85 ed		 test	 ebp, ebp
  00008	89 4c 24 04	 mov	 DWORD PTR _this$[esp+8], ecx
  0000c	0f 84 bf 01 00
	00		 je	 $L105095
  00012	53		 push	 ebx
  00013	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pChar$[esp+8]
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 b1 01 00
	00		 je	 $L105650
  0001f	56		 push	 esi
  00020	57		 push	 edi

; 276  :     
; 277  : 	_LPUDPPACKET pUDPPacket = new _UDPPACKET;

  00021	68 24 04 00 00	 push	 1060			; 00000424H
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b f0		 mov	 esi, eax

; 278  : 	memset( pUDPPacket, 0x00, sizeof(_UDPPACKET));

  0002d	33 c0		 xor	 eax, eax
  0002f	b9 09 01 00 00	 mov	 ecx, 265		; 00000109H
  00034	8b fe		 mov	 edi, esi
  00036	f3 ab		 rep stosd

; 279  : 	_LPLOG_DATA_ pLogData = (_LPLOG_DATA_)pUDPPacket->szPacket;
; 280  : 
; 281  : 
; 282  : 	pLogData->dwAction	=	LOGLOGIN_GAMESTART;	
; 283  : 	pLogData->dwServerID=	pGroupID;

  00038	0f b6 44 24 24	 movzx	 eax, BYTE PTR _pGroupID$[esp+20]
  0003d	c7 46 48 08 00
	00 00		 mov	 DWORD PTR [esi+72], 8
  00044	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 284  : 
; 285  : 	lstrcpy( pLogData->szClientIP, inet_ntoa(pUser->m_addr.sin_addr));

  00047	8b 4d 40	 mov	 ecx, DWORD PTR [ebp+64]
  0004a	83 c4 04	 add	 esp, 4
  0004d	51		 push	 ecx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00054	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcpyA@8
  0005a	50		 push	 eax
  0005b	8d 56 38	 lea	 edx, DWORD PTR [esi+56]
  0005e	52		 push	 edx
  0005f	ff d7		 call	 edi

; 286  : 
; 287  : 	pLogData->dwKey[0]	=	pUser->m_dwID;

  00061	8b 85 04 01 01
	00		 mov	 eax, DWORD PTR [ebp+65796]
  00067	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0006a	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 288  : 	lstrcpy( pLogData->szKey[0], pUser->m_strUserID);

  00071	8b 8d fc 00 01
	00		 mov	 ecx, DWORD PTR [ebp+65788]
  00077	51		 push	 ecx
  00078	8d 96 b4 00 00
	00		 lea	 edx, DWORD PTR [esi+180]
  0007e	52		 push	 edx
  0007f	ff d7		 call	 edi

; 289  : 	
; 290  : 	lstrcpy( pLogData->szKey[1], pChar->m_strName);

  00081	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00084	50		 push	 eax
  00085	8d 8e e6 00 00
	00		 lea	 ecx, DWORD PTR [esi+230]
  0008b	51		 push	 ecx
  0008c	ff d7		 call	 edi

; 291  : 
; 292  : 
; 293  : 	pLogData->dwKey[3]	=	pChar->m_bRace;

  0008e	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  00092	99		 cdq
  00093	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00096	89 56 78	 mov	 DWORD PTR [esi+120], edx

; 294  : 	pLogData->dwKey[5]	=	pChar->m_bClass;

  00099	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  0009d	99		 cdq
  0009e	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000a4	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx

; 295  : 
; 296  : 	pLogData->dwKey[9]	=	pChar->m_bCountry;

  000aa	0f b6 43 0d	 movzx	 eax, BYTE PTR [ebx+13]
  000ae	99		 cdq
  000af	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  000b5	89 96 a8 00 00
	00		 mov	 DWORD PTR [esi+168], edx

; 297  : 	pLogData->dwKey[10]	=	pChar->m_bLevel;

  000bb	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  000bf	99		 cdq
  000c0	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax

; 298  :     
; 299  : 	switch(pReturnCode)

  000c6	8b 44 24 1c	 mov	 eax, DWORD PTR _pReturnCode$[esp+16]
  000ca	83 f8 03	 cmp	 eax, 3
  000cd	89 96 b0 00 00
	00		 mov	 DWORD PTR [esi+176], edx
  000d3	77 59		 ja	 SHORT $L105103
  000d5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L105652[eax*4]
$L105106:

; 300  : 	{
; 301  : 	case SR_SUCCESS:		wsprintf(pLogData->szKey[4], "SUCCESS %s:%d (%d)",pIP, pPort, pServerID);	break;

  000dc	0f b6 54 24 30	 movzx	 edx, BYTE PTR _pServerID$[esp+16]
  000e1	0f b7 44 24 2c	 movzx	 eax, WORD PTR _pPort$[esp+16]
  000e6	8b 4c 24 28	 mov	 ecx, DWORD PTR _pIP$[esp+16]
  000ea	52		 push	 edx
  000eb	50		 push	 eax
  000ec	51		 push	 ecx
  000ed	8d 96 7c 01 00
	00		 lea	 edx, DWORD PTR [esi+380]
  000f3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@FKJOGMGF@SUCCESS?5?$CFs?3?$CFd?5?$CI?$CFd?$CJ?$AA@
  000f8	52		 push	 edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000ff	83 c4 14	 add	 esp, 20			; 00000014H
  00102	eb 2a		 jmp	 SHORT $L105103
$L105108:

; 302  : 
; 303  : 	case SR_NOSERVER:		lstrcpy( pLogData->szKey[4], "NOSERVER");		break;

  00104	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08OANKDHFI@NOSERVER?$AA@
  00109	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  0010f	50		 push	 eax
  00110	eb 1a		 jmp	 SHORT $L105651
$L105110:

; 304  : 	case SR_NOGROUP:		lstrcpy( pLogData->szKey[4], "NOGROUP");		break;

  00112	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07FHLMKKMC@NOGROUP?$AA@
  00117	8d 8e 7c 01 00
	00		 lea	 ecx, DWORD PTR [esi+380]
  0011d	51		 push	 ecx
  0011e	eb 0c		 jmp	 SHORT $L105651
$L105111:

; 305  : 	case SR_INTERNAL:		lstrcpy( pLogData->szKey[4], "INTERNAL");		break;

  00120	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08MLFDIMPC@INTERNAL?$AA@
  00125	8d 96 7c 01 00
	00		 lea	 edx, DWORD PTR [esi+380]
  0012b	52		 push	 edx
$L105651:
  0012c	ff d7		 call	 edi
$L105103:

; 306  : 	}
; 307  : 
; 308  : 
; 309  : 	pLogData->dwFormat = LF_CHARBASE;

  0012e	c7 86 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+532], 1

; 310  : 
; 311  : 	//	Set the Character Base Information
; 312  : 	_LPLOG_CHARBASE_ pCharBase = (_LPLOG_CHARBASE_)pLogData->szLog;
; 313  : 
; 314  : 	pCharBase->dwCharID = pChar->m_dwCharID;

  00138	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013a	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax

; 315  : 	lstrcpy( pCharBase->szName, pChar->m_strName);

  00140	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00143	51		 push	 ecx
  00144	8d 96 1c 02 00
	00		 lea	 edx, DWORD PTR [esi+540]
  0014a	52		 push	 edx
  0014b	ff d7		 call	 edi

; 316  : 	
; 317  : 
; 318  : 	pCharBase->bSlot	= pChar->m_bSlot;

  0014d	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  00150	88 86 30 02 00
	00		 mov	 BYTE PTR [esi+560], al

; 319  : 
; 320  : 	pCharBase->bLevel	= pChar->m_bLevel;

  00156	8a 4b 0a	 mov	 cl, BYTE PTR [ebx+10]
  00159	88 8e 31 02 00
	00		 mov	 BYTE PTR [esi+561], cl

; 321  : 
; 322  : 	pCharBase->bClass	= pChar->m_bClass;

  0015f	8a 53 0b	 mov	 dl, BYTE PTR [ebx+11]
  00162	88 96 32 02 00
	00		 mov	 BYTE PTR [esi+562], dl

; 323  : 
; 324  : 	pCharBase->bRace	= pChar->m_bRace;

  00168	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  0016b	88 86 33 02 00
	00		 mov	 BYTE PTR [esi+563], al

; 325  : 	pCharBase->bCountry	= pChar->m_bCountry;

  00171	8a 4b 0d	 mov	 cl, BYTE PTR [ebx+13]
  00174	88 8e 34 02 00
	00		 mov	 BYTE PTR [esi+564], cl

; 326  : 	pCharBase->bSex		= pChar->m_bSex;

  0017a	8a 53 0e	 mov	 dl, BYTE PTR [ebx+14]
  0017d	88 96 35 02 00
	00		 mov	 BYTE PTR [esi+565], dl

; 327  : 	pCharBase->bHair	= pChar->m_bHair;

  00183	8a 43 0f	 mov	 al, BYTE PTR [ebx+15]
  00186	88 86 36 02 00
	00		 mov	 BYTE PTR [esi+566], al

; 328  : 	pCharBase->bFace	= pChar->m_bFace;

  0018c	8a 4b 10	 mov	 cl, BYTE PTR [ebx+16]
  0018f	88 8e 37 02 00
	00		 mov	 BYTE PTR [esi+567], cl

; 329  : 	pCharBase->bBody	= pChar->m_bBody;

  00195	8a 53 11	 mov	 dl, BYTE PTR [ebx+17]
  00198	88 96 38 02 00
	00		 mov	 BYTE PTR [esi+568], dl

; 330  : 	pCharBase->bPants	= pChar->m_bPants;

  0019e	8a 43 12	 mov	 al, BYTE PTR [ebx+18]
  001a1	88 86 39 02 00
	00		 mov	 BYTE PTR [esi+569], al

; 331  : 	pCharBase->bHand	= pChar->m_bHand;

  001a7	8a 4b 13	 mov	 cl, BYTE PTR [ebx+19]
  001aa	88 8e 3a 02 00
	00		 mov	 BYTE PTR [esi+570], cl

; 332  : 	pCharBase->bFoot	= pChar->m_bFoot;

  001b0	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]

; 333  : 	
; 334  : 	pCharBase->dwRegion	= pChar->m_dwRegion;
; 335  : 
; 336  : 
; 337  : 	Log( pUDPPacket, sizeof(_LOG_CHARBASE_) );

  001b3	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  001b7	88 96 3b 02 00
	00		 mov	 BYTE PTR [esi+571], dl
  001bd	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  001c0	6a 28		 push	 40			; 00000028H
  001c2	56		 push	 esi
  001c3	89 86 3c 02 00
	00		 mov	 DWORD PTR [esi+572], eax
  001c9	e8 00 00 00 00	 call	 ?Log@CUdpSocket@@QAEXPAU_UDPPACKET@@H@Z ; CUdpSocket::Log
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
$L105650:
  001d0	5b		 pop	 ebx
$L105095:
  001d1	5d		 pop	 ebp

; 338  : }

  001d2	59		 pop	 ecx
  001d3	c2 1c 00	 ret	 28			; 0000001cH
  001d6	8b ff		 npad	 2
$L105652:
  001d8	00 00 00 00	 DD	 $L105106
  001dc	00 00 00 00	 DD	 $L105108
  001e0	00 00 00 00	 DD	 $L105110
  001e4	00 00 00 00	 DD	 $L105111
?LogGameStart@CUdpSocket@@QAEXPAVCTUser@@KEPAUtagTCHAR@@PADGE@Z ENDP ; CUdpSocket::LogGameStart
_TEXT	ENDS
END
