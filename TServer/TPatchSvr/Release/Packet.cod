; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\Packet.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0COverlappedEx@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCOverlappedEx@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1COverlappedEx@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPacket@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPacket@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPacket@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExpandIoBuffer@CPacket@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CPacket@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@CPacket@@QAEPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CPacket@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadBufferFull@CPacket@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEOF@CPacket@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanRead@CPacket@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanWrite@CPacket@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CPacket@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetID@CPacket@@QAEAAV1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CPacket@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Read@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Write@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CPacket@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyData@CPacket@@QAEXPAV1@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddData@CPacket@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DetachBinary@CPacket@@QAEHPAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AttachBinary@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReadBytes@CPacket@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadBytes@CPacket@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@F@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CPacket@@QAEAAV0@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CPacket@@QAEAAV0@AA_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rewind@CPacket@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CPacket@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7COverlappedEx@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0COverlappedEx@@QAE@XZ			; COverlappedEx::COverlappedEx
PUBLIC	??_7COverlappedEx@@6B@				; COverlappedEx::`vftable'
PUBLIC	??_GCOverlappedEx@@UAEPAXI@Z			; COverlappedEx::`scalar deleting destructor'
EXTRN	??_ECOverlappedEx@@UAEPAXI@Z:NEAR		; COverlappedEx::`vector deleting destructor'
;	COMDAT ??_7COverlappedEx@@6B@
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tpatchsvr\packet.cpp
CONST	SEGMENT
??_7COverlappedEx@@6B@ DD FLAT:??_ECOverlappedEx@@UAEPAXI@Z ; COverlappedEx::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0COverlappedEx@@QAE@XZ
_TEXT	SEGMENT
??0COverlappedEx@@QAE@XZ PROC NEAR			; COverlappedEx::COverlappedEx, COMDAT
; _this$ = ecx

; 8    : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7COverlappedEx@@6B@

; 9    : 	memset( &m_ov, 0, sizeof(OVERLAPPED));

  00008	33 c9		 xor	 ecx, ecx
  0000a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx
  0000f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00012	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00015	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00018	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 10   : 
; 11   : 	m_bTYPE = TOV_SSN_RECV;

  0001b	c6 40 1c 01	 mov	 BYTE PTR [eax+28], 1

; 12   : 	m_pOBJ = NULL;

  0001f	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 13   : }

  00022	c3		 ret	 0
??0COverlappedEx@@QAE@XZ ENDP				; COverlappedEx::COverlappedEx
_TEXT	ENDS
PUBLIC	??1COverlappedEx@@UAE@XZ			; COverlappedEx::~COverlappedEx
; Function compile flags: /Ogty
;	COMDAT ??1COverlappedEx@@UAE@XZ
_TEXT	SEGMENT
??1COverlappedEx@@UAE@XZ PROC NEAR			; COverlappedEx::~COverlappedEx, COMDAT
; _this$ = ecx

; 16   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7COverlappedEx@@6B@

; 17   : }

  00006	c3		 ret	 0
??1COverlappedEx@@UAE@XZ ENDP				; COverlappedEx::~COverlappedEx
_TEXT	ENDS
PUBLIC	??1CPacket@@UAE@XZ				; CPacket::~CPacket
PUBLIC	??_7CPacket@@6B@				; CPacket::`vftable'
PUBLIC	??_GCPacket@@UAEPAXI@Z				; CPacket::`scalar deleting destructor'
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_ECPacket@@UAEPAXI@Z:NEAR			; CPacket::`vector deleting destructor'
;	COMDAT ??_7CPacket@@6B@
CONST	SEGMENT
??_7CPacket@@6B@ DD FLAT:??_ECPacket@@UAEPAXI@Z		; CPacket::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1CPacket@@UAE@XZ
_TEXT	SEGMENT
??1CPacket@@UAE@XZ PROC NEAR				; CPacket::~CPacket, COMDAT
; _this$ = ecx

; 34   : 	if( m_pBuf && m_dwBufferSize )

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	85 c0		 test	 eax, eax
  00005	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CPacket@@6B@
  0000b	74 0e		 je	 SHORT $L92986
  0000d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00010	85 d2		 test	 edx, edx
  00012	74 07		 je	 SHORT $L92986

; 35   : 		delete[] m_pBuf;

  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	59		 pop	 ecx
$L92986:

; 36   : }

  0001b	c3		 ret	 0
??1CPacket@@UAE@XZ ENDP					; CPacket::~CPacket
_TEXT	ENDS
PUBLIC	?ExpandIoBuffer@CPacket@@QAEKK@Z		; CPacket::ExpandIoBuffer
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogty
;	COMDAT ?ExpandIoBuffer@CPacket@@QAEKK@Z
_TEXT	SEGMENT
_dwExpandSize$ = 8					; size = 4
_dwNewSize$ = 8						; size = 4
?ExpandIoBuffer@CPacket@@QAEKK@Z PROC NEAR		; CPacket::ExpandIoBuffer, COMDAT
; _this$ = ecx

; 39   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 40   : 	DWORD dwPrevOffset = PACKET_HEADER_SIZE;
; 41   : 	DWORD dwExpandSize;
; 42   : 	DWORD dwAddSize =0;
; 43   : 
; 44   : 	LPBYTE pExpand = NULL;
; 45   : 
; 46   : 	if( dwNewSize != -1 )

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _dwNewSize$[esp+8]
  00007	83 ff ff	 cmp	 edi, -1
  0000a	8b d9		 mov	 ebx, ecx
  0000c	be 08 00 00 00	 mov	 esi, 8
  00011	74 06		 je	 SHORT $L92997

; 47   : 		dwExpandSize = dwNewSize;

  00013	89 7c 24 10	 mov	 DWORD PTR _dwExpandSize$[esp+8], edi

; 48   : 	else

  00017	eb 0e		 jmp	 SHORT $L92998
$L92997:

; 49   : 		dwExpandSize = m_dwBufferSize + DEF_PACKET_SIZE;

  00019	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0001c	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00021	89 44 24 10	 mov	 DWORD PTR _dwExpandSize$[esp+8], eax
  00025	8b f8		 mov	 edi, eax
$L92998:

; 50   : 
; 51   : 	if( dwExpandSize <= m_dwBufferSize )

  00027	3b 7b 10	 cmp	 edi, DWORD PTR [ebx+16]

; 52   : 		return dwAddSize;

  0002a	76 60		 jbe	 SHORT $L93601
  0002c	55		 push	 ebp

; 53   : 
; 54   : 	pExpand = new BYTE[dwExpandSize];

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 55   : 	memset(pExpand, 0, sizeof(BYTE) * dwExpandSize);

  00033	8b cf		 mov	 ecx, edi
  00035	8b d1		 mov	 edx, ecx
  00037	8b e8		 mov	 ebp, eax
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	33 c0		 xor	 eax, eax
  0003e	8b fd		 mov	 edi, ebp
  00040	f3 ab		 rep stosd
  00042	8b ca		 mov	 ecx, edx
  00044	83 e1 03	 and	 ecx, 3
  00047	f3 aa		 rep stosb

; 56   : 
; 57   : 	if(m_pBuf)

  00049	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0004c	83 c4 04	 add	 esp, 4
  0004f	85 c0		 test	 eax, eax
  00051	74 26		 je	 SHORT $L93003

; 58   : 	{
; 59   : 		memcpy( pExpand, m_pBuf, m_dwBufferSize);

  00053	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00056	8b f0		 mov	 esi, eax
  00058	8b c1		 mov	 eax, ecx
  0005a	c1 e9 02	 shr	 ecx, 2
  0005d	8b fd		 mov	 edi, ebp
  0005f	f3 a5		 rep movsd
  00061	8b c8		 mov	 ecx, eax
  00063	83 e1 03	 and	 ecx, 3
  00066	f3 a4		 rep movsb

; 60   : 		dwPrevOffset = DWORD(m_ptrOffset - m_pBuf);

  00068	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0006b	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 61   : 
; 62   : 		delete[] m_pBuf;

  0006e	50		 push	 eax
  0006f	2b f0		 sub	 esi, eax
  00071	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00076	83 c4 04	 add	 esp, 4
$L93003:

; 63   : 	}
; 64   : 
; 65   : 	m_dwBufferSize = dwExpandSize;

  00079	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwExpandSize$[esp+12]

; 66   : 	m_pBuf = pExpand;

  0007d	89 6b 0c	 mov	 DWORD PTR [ebx+12], ebp

; 67   : 
; 68   : 	m_pHeader = (LPPACKETHEADER) pExpand;

  00080	89 6b 04	 mov	 DWORD PTR [ebx+4], ebp

; 69   : 	m_ptrOffset = m_pBuf + dwPrevOffset;

  00083	03 ee		 add	 ebp, esi
  00085	89 6b 08	 mov	 DWORD PTR [ebx+8], ebp
  00088	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  0008b	5d		 pop	 ebp
$L93601:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 70   : 
; 71   : 	return dwAddSize;

  0008e	33 c0		 xor	 eax, eax
  00090	5b		 pop	 ebx

; 72   : }

  00091	c2 04 00	 ret	 4
?ExpandIoBuffer@CPacket@@QAEKK@Z ENDP			; CPacket::ExpandIoBuffer
_TEXT	ENDS
PUBLIC	?Clear@CPacket@@QAEXXZ				; CPacket::Clear
; Function compile flags: /Ogty
;	COMDAT ?Clear@CPacket@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPacket@@QAEXXZ PROC NEAR			; CPacket::Clear, COMDAT
; _this$ = ecx

; 75   : {

  00000	8b d1		 mov	 edx, ecx

; 76   : 	memset( m_pBuf, 0, m_dwBufferSize);

  00002	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
  00009	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  0000c	c1 e9 02	 shr	 ecx, 2
  0000f	33 c0		 xor	 eax, eax
  00011	f3 ab		 rep stosd
  00013	8b ce		 mov	 ecx, esi
  00015	83 e1 03	 and	 ecx, 3
  00018	f3 aa		 rep stosb

; 77   : 	m_dwReadBytes = 0;
; 78   : 
; 79   : 	if(m_bType == PACKET_SEND)

  0001a	80 7a 18 01	 cmp	 BYTE PTR [edx+24], 1
  0001e	5f		 pop	 edi
  0001f	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  00026	5e		 pop	 esi
  00027	75 08		 jne	 SHORT $L93009

; 80   : 		m_pHeader->m_wSize = PACKET_HEADER_SIZE;

  00029	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002c	66 c7 00 08 00	 mov	 WORD PTR [eax], 8
$L93009:

; 81   : 
; 82   : 	m_ptrOffset = m_pBuf + PACKET_HEADER_SIZE;

  00031	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00034	83 c1 08	 add	 ecx, 8
  00037	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 83   : }

  0003a	c3		 ret	 0
?Clear@CPacket@@QAEXXZ ENDP				; CPacket::Clear
_TEXT	ENDS
PUBLIC	?GetBuffer@CPacket@@QAEPAEXZ			; CPacket::GetBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetBuffer@CPacket@@QAEPAEXZ
_TEXT	SEGMENT
?GetBuffer@CPacket@@QAEPAEXZ PROC NEAR			; CPacket::GetBuffer, COMDAT
; _this$ = ecx

; 87   : 	return m_pBuf;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 88   : }

  00003	c3		 ret	 0
?GetBuffer@CPacket@@QAEPAEXZ ENDP			; CPacket::GetBuffer
_TEXT	ENDS
PUBLIC	?GetID@CPacket@@QAEGXZ				; CPacket::GetID
; Function compile flags: /Ogty
;	COMDAT ?GetID@CPacket@@QAEGXZ
_TEXT	SEGMENT
?GetID@CPacket@@QAEGXZ PROC NEAR			; CPacket::GetID, COMDAT
; _this$ = ecx

; 131  : 	return m_pHeader ? m_pHeader->m_wID : 0xFFFF;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 05		 je	 SHORT $L93611
  00007	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]

; 132  : }

  0000b	c3		 ret	 0
$L93611:

; 131  : 	return m_pHeader ? m_pHeader->m_wID : 0xFFFF;

  0000c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 132  : }

  00011	c3		 ret	 0
?GetID@CPacket@@QAEGXZ ENDP				; CPacket::GetID
_TEXT	ENDS
PUBLIC	?SetID@CPacket@@QAEAAV1@G@Z			; CPacket::SetID
; Function compile flags: /Ogty
;	COMDAT ?SetID@CPacket@@QAEAAV1@G@Z
_TEXT	SEGMENT
_wID$ = 8						; size = 2
?SetID@CPacket@@QAEAAV1@G@Z PROC NEAR			; CPacket::SetID, COMDAT
; _this$ = ecx

; 135  : {

  00000	8b c1		 mov	 eax, ecx

; 136  : 	if(m_pHeader)

  00002	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00005	85 c9		 test	 ecx, ecx
  00007	74 09		 je	 SHORT $L93045

; 137  : 		m_pHeader->m_wID = wID;

  00009	66 8b 54 24 04	 mov	 dx, WORD PTR _wID$[esp-4]
  0000e	66 89 51 02	 mov	 WORD PTR [ecx+2], dx
$L93045:

; 138  : 
; 139  : 	return *this;
; 140  : }

  00012	c2 04 00	 ret	 4
?SetID@CPacket@@QAEAAV1@G@Z ENDP			; CPacket::SetID
_TEXT	ENDS
PUBLIC	?GetSize@CPacket@@QAEGXZ			; CPacket::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@CPacket@@QAEGXZ
_TEXT	SEGMENT
?GetSize@CPacket@@QAEGXZ PROC NEAR			; CPacket::GetSize, COMDAT
; _this$ = ecx

; 144  : 	return m_pHeader ? m_pHeader->m_wSize : 0xFFFF;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 04		 je	 SHORT $L93620
  00007	0f b7 00	 movzx	 eax, WORD PTR [eax]

; 145  : }

  0000a	c3		 ret	 0
$L93620:

; 144  : 	return m_pHeader ? m_pHeader->m_wSize : 0xFFFF;

  0000b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 145  : }

  00010	c3		 ret	 0
?GetSize@CPacket@@QAEGXZ ENDP				; CPacket::GetSize
_TEXT	ENDS
PUBLIC	?Copy@CPacket@@QAEXPAV1@@Z			; CPacket::Copy
; Function compile flags: /Ogty
;	COMDAT ?Copy@CPacket@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
?Copy@CPacket@@QAEXPAV1@@Z PROC NEAR			; CPacket::Copy, COMDAT
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 175  : 	if(!pMsg)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pMsg$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	8b e9		 mov	 ebp, ecx
  0000a	74 52		 je	 SHORT $L93067

; 176  : 		return;
; 177  : 
; 178  : 	DWORD dwPacketSize = pMsg->GetSize();

  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	85 c0		 test	 eax, eax
  00011	74 05		 je	 SHORT $L93629
  00013	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00016	eb 05		 jmp	 SHORT $L93630
$L93629:
  00018	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93630:
  0001d	53		 push	 ebx
  0001e	0f b7 d8	 movzx	 ebx, ax

; 179  : 	if( dwPacketSize >= MAX_PACKET_SIZE )

  00021	81 fb ff ff 00
	00		 cmp	 ebx, 65535		; 0000ffffH
  00027	73 34		 jae	 SHORT $L93632

; 180  : 		return;
; 181  : 
; 182  : 	if( m_dwBufferSize < dwPacketSize )

  00029	39 5d 10	 cmp	 DWORD PTR [ebp+16], ebx
  0002c	73 08		 jae	 SHORT $L93071

; 183  : 		ExpandIoBuffer(dwPacketSize);

  0002e	53		 push	 ebx
  0002f	8b cd		 mov	 ecx, ebp
  00031	e8 00 00 00 00	 call	 ?ExpandIoBuffer@CPacket@@QAEKK@Z ; CPacket::ExpandIoBuffer
$L93071:
  00036	57		 push	 edi

; 184  : 
; 185  : 	Clear();

  00037	8b cd		 mov	 ecx, ebp
  00039	e8 00 00 00 00	 call	 ?Clear@CPacket@@QAEXXZ	; CPacket::Clear

; 186  : 
; 187  : 	memcpy( m_pBuf, pMsg->m_pBuf, dwPacketSize);

  0003e	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  00041	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  00044	8b cb		 mov	 ecx, ebx
  00046	8b c1		 mov	 eax, ecx
  00048	c1 e9 02	 shr	 ecx, 2
  0004b	f3 a5		 rep movsd
  0004d	8b c8		 mov	 ecx, eax
  0004f	83 e1 03	 and	 ecx, 3
  00052	f3 a4		 rep movsb

; 188  : 	m_ptrOffset = m_pBuf + dwPacketSize;

  00054	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00057	03 cb		 add	 ecx, ebx
  00059	89 4d 08	 mov	 DWORD PTR [ebp+8], ecx
  0005c	5f		 pop	 edi
$L93632:
  0005d	5b		 pop	 ebx
$L93067:
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp

; 189  : }

  00060	c2 04 00	 ret	 4
?Copy@CPacket@@QAEXPAV1@@Z ENDP				; CPacket::Copy
_TEXT	ENDS
PUBLIC	?CopyData@CPacket@@QAEXPAV1@G@Z			; CPacket::CopyData
; Function compile flags: /Ogty
;	COMDAT ?CopyData@CPacket@@QAEXPAV1@G@Z
_TEXT	SEGMENT
_wAddSize$ = 8						; size = 2
_pMsg$ = 8						; size = 4
_wDeleteSize$ = 12					; size = 2
?CopyData@CPacket@@QAEXPAV1@G@Z PROC NEAR		; CPacket::CopyData, COMDAT
; _this$ = ecx

; 192  : {

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 193  : 	if(!pMsg || pMsg->GetSize() < wDeleteSize + PACKET_HEADER_SIZE)

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _pMsg$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	8b d9		 mov	 ebx, ecx
  0000a	0f 84 9d 00 00
	00		 je	 $L93079
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00013	85 c0		 test	 eax, eax
  00015	74 05		 je	 SHORT $L93640
  00017	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001a	eb 05		 jmp	 SHORT $L93641
$L93640:
  0001c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93641:
  00021	8b 54 24 10	 mov	 edx, DWORD PTR _wDeleteSize$[esp+4]
  00025	55		 push	 ebp
  00026	56		 push	 esi
  00027	0f b7 f2	 movzx	 esi, dx
  0002a	0f b7 c9	 movzx	 ecx, cx
  0002d	8d 6e 08	 lea	 ebp, DWORD PTR [esi+8]
  00030	3b cd		 cmp	 ecx, ebp
  00032	72 77		 jb	 SHORT $L93664

; 194  : 		return;
; 195  : 
; 196  : 	WORD wAddSize = pMsg->GetSize() - PACKET_HEADER_SIZE - wDeleteSize;

  00034	85 c0		 test	 eax, eax
  00036	74 05		 je	 SHORT $L93647
  00038	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0003b	eb 05		 jmp	 SHORT $L93648
$L93647:
  0003d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93648:

; 197  : 
; 198  : 	if( m_dwBufferSize < DWORD(GetSize() + wAddSize) )

  00042	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00045	2b c2		 sub	 eax, edx
  00047	83 e8 08	 sub	 eax, 8
  0004a	85 c9		 test	 ecx, ecx
  0004c	89 44 24 14	 mov	 DWORD PTR _wAddSize$[esp+12], eax
  00050	74 05		 je	 SHORT $L93654
  00052	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00055	eb 05		 jmp	 SHORT $L93655
$L93654:
  00057	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L93655:
  0005c	0f b7 e8	 movzx	 ebp, ax
  0005f	0f b7 d2	 movzx	 edx, dx
  00062	03 d5		 add	 edx, ebp
  00064	39 53 10	 cmp	 DWORD PTR [ebx+16], edx
  00067	73 1f		 jae	 SHORT $L93082

; 199  : 		ExpandIoBuffer(GetSize() + wAddSize);

  00069	85 c9		 test	 ecx, ecx
  0006b	74 05		 je	 SHORT $L93661
  0006d	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00070	eb 05		 jmp	 SHORT $L93662
$L93661:
  00072	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93662:
  00077	0f b7 c0	 movzx	 eax, ax
  0007a	03 c5		 add	 eax, ebp
  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?ExpandIoBuffer@CPacket@@QAEKK@Z ; CPacket::ExpandIoBuffer
  00084	8b 44 24 14	 mov	 eax, DWORD PTR _wAddSize$[esp+12]
$L93082:

; 200  : 
; 201  : 	memcpy( m_ptrOffset, pMsg->m_pBuf+PACKET_HEADER_SIZE+wDeleteSize, wAddSize);

  00088	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0008b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0008e	8d 74 32 08	 lea	 esi, DWORD PTR [edx+esi+8]
  00092	8b cd		 mov	 ecx, ebp
  00094	8b d1		 mov	 edx, ecx
  00096	c1 e9 02	 shr	 ecx, 2
  00099	f3 a5		 rep movsd
  0009b	8b ca		 mov	 ecx, edx
  0009d	83 e1 03	 and	 ecx, 3
  000a0	f3 a4		 rep movsb

; 202  : 	m_pHeader->m_wSize += wAddSize;

  000a2	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000a5	66 01 01	 add	 WORD PTR [ecx], ax

; 203  : 	m_ptrOffset += wAddSize;

  000a8	01 6b 08	 add	 DWORD PTR [ebx+8], ebp
$L93664:
  000ab	5e		 pop	 esi
  000ac	5d		 pop	 ebp
$L93079:
  000ad	5f		 pop	 edi
  000ae	5b		 pop	 ebx

; 204  : }

  000af	c2 08 00	 ret	 8
?CopyData@CPacket@@QAEXPAV1@G@Z ENDP			; CPacket::CopyData
_TEXT	ENDS
PUBLIC	?AddData@CPacket@@QAEXPAV1@@Z			; CPacket::AddData
; Function compile flags: /Ogty
;	COMDAT ?AddData@CPacket@@QAEXPAV1@@Z
_TEXT	SEGMENT
_wDataSize$ = 8						; size = 2
_pMsg$ = 8						; size = 4
?AddData@CPacket@@QAEXPAV1@@Z PROC NEAR			; CPacket::AddData, COMDAT
; _this$ = ecx

; 207  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 208  : 	if(!pMsg)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _pMsg$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	0f 84 98 00 00
	00		 je	 $L93087

; 209  : 		return;
; 210  : 
; 211  : 	WORD wDataSize = pMsg->GetSize() - PACKET_HEADER_SIZE;

  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	85 c0		 test	 eax, eax
  00015	74 05		 je	 SHORT $L93673
  00017	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0001a	eb 05		 jmp	 SHORT $L93674
$L93673:
  0001c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93674:
  00021	8d 50 f8	 lea	 edx, DWORD PTR [eax-8]

; 212  : 	if( wDataSize+GetSize() >= MAX_PACKET_SIZE )

  00024	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00027	85 c0		 test	 eax, eax
  00029	89 54 24 0c	 mov	 DWORD PTR _wDataSize$[esp+4], edx
  0002d	74 05		 je	 SHORT $L93680
  0002f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00032	eb 05		 jmp	 SHORT $L93681
$L93680:
  00034	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93681:
  00039	55		 push	 ebp
  0003a	0f b7 ea	 movzx	 ebp, dx
  0003d	0f b7 c9	 movzx	 ecx, cx
  00040	03 cd		 add	 ecx, ebp
  00042	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00048	7d 5d		 jge	 SHORT $L93697

; 213  : 		return;
; 214  : 
; 215  : 	if( m_dwBufferSize < DWORD(wDataSize + GetSize())  )

  0004a	85 c0		 test	 eax, eax
  0004c	74 05		 je	 SHORT $L93687
  0004e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00051	eb 05		 jmp	 SHORT $L93688
$L93687:
  00053	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93688:
  00058	0f b7 c9	 movzx	 ecx, cx
  0005b	57		 push	 edi
  0005c	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0005f	03 cd		 add	 ecx, ebp
  00061	3b f9		 cmp	 edi, ecx
  00063	73 1f		 jae	 SHORT $L93092

; 216  : 		ExpandIoBuffer(wDataSize + GetSize());

  00065	85 c0		 test	 eax, eax
  00067	74 05		 je	 SHORT $L93694
  00069	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0006c	eb 05		 jmp	 SHORT $L93695
$L93694:
  0006e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93695:
  00073	0f b7 d0	 movzx	 edx, ax
  00076	03 d5		 add	 edx, ebp
  00078	52		 push	 edx
  00079	8b cb		 mov	 ecx, ebx
  0007b	e8 00 00 00 00	 call	 ?ExpandIoBuffer@CPacket@@QAEKK@Z ; CPacket::ExpandIoBuffer
  00080	8b 54 24 14	 mov	 edx, DWORD PTR _wDataSize$[esp+12]
$L93092:

; 217  : 
; 218  : 	memcpy( m_ptrOffset, pMsg->m_pBuf+PACKET_HEADER_SIZE, wDataSize);

  00084	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  00087	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0008a	8b cd		 mov	 ecx, ebp
  0008c	8b c1		 mov	 eax, ecx
  0008e	c1 e9 02	 shr	 ecx, 2
  00091	83 c6 08	 add	 esi, 8
  00094	f3 a5		 rep movsd
  00096	8b c8		 mov	 ecx, eax
  00098	83 e1 03	 and	 ecx, 3
  0009b	f3 a4		 rep movsb

; 219  : 	m_pHeader->m_wSize += wDataSize;

  0009d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a0	66 01 10	 add	 WORD PTR [eax], dx

; 220  : 	m_ptrOffset += wDataSize;

  000a3	01 6b 08	 add	 DWORD PTR [ebx+8], ebp
  000a6	5f		 pop	 edi
$L93697:
  000a7	5d		 pop	 ebp
$L93087:
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 221  : }

  000aa	c2 04 00	 ret	 4
?AddData@CPacket@@QAEXPAV1@@Z ENDP			; CPacket::AddData
_TEXT	ENDS
PUBLIC	?GetReadBytes@CPacket@@QAEKXZ			; CPacket::GetReadBytes
; Function compile flags: /Ogty
;	COMDAT ?GetReadBytes@CPacket@@QAEKXZ
_TEXT	SEGMENT
?GetReadBytes@CPacket@@QAEKXZ PROC NEAR			; CPacket::GetReadBytes, COMDAT
; _this$ = ecx

; 248  : 	return m_dwReadBytes;

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 249  : }

  00003	c3		 ret	 0
?GetReadBytes@CPacket@@QAEKXZ ENDP			; CPacket::GetReadBytes
_TEXT	ENDS
PUBLIC	?ReadBytes@CPacket@@QAEHK@Z			; CPacket::ReadBytes
; Function compile flags: /Ogty
;	COMDAT ?ReadBytes@CPacket@@QAEHK@Z
_TEXT	SEGMENT
_dwReadBytes$ = 8					; size = 4
?ReadBytes@CPacket@@QAEHK@Z PROC NEAR			; CPacket::ReadBytes, COMDAT
; _this$ = ecx

; 253  : 	DWORD dwTotalBytes = m_dwReadBytes + dwReadBytes;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _dwReadBytes$[esp-4]
  00004	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00007	03 c2		 add	 eax, edx

; 254  : 
; 255  : 	if( dwTotalBytes > m_dwBufferSize)

  00009	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000c	76 05		 jbe	 SHORT $L93118

; 256  : 		return FALSE;

  0000e	33 c0		 xor	 eax, eax

; 260  : }

  00010	c2 04 00	 ret	 4
$L93118:

; 257  : 
; 258  : 	m_dwReadBytes += dwReadBytes;

  00013	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 259  : 	return TRUE;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 260  : }

  0001b	c2 04 00	 ret	 4
?ReadBytes@CPacket@@QAEHK@Z ENDP			; CPacket::ReadBytes
_TEXT	ENDS
PUBLIC	?Rewind@CPacket@@QAEXH@Z			; CPacket::Rewind
; Function compile flags: /Ogty
;	COMDAT ?Rewind@CPacket@@QAEXH@Z
_TEXT	SEGMENT
_bWrite$ = 8						; size = 4
?Rewind@CPacket@@QAEXH@Z PROC NEAR			; CPacket::Rewind, COMDAT
; _this$ = ecx

; 401  : 	if(bWrite)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bWrite$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L93251

; 402  : 		m_pHeader->m_wSize = PACKET_HEADER_SIZE;

  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	66 c7 00 08 00	 mov	 WORD PTR [eax], 8
$L93251:

; 403  : 	m_ptrOffset = m_pBuf + PACKET_HEADER_SIZE;

  00010	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00013	83 c2 08	 add	 edx, 8
  00016	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 404  : }

  00019	c2 04 00	 ret	 4
?Rewind@CPacket@@QAEXH@Z ENDP				; CPacket::Rewind
_TEXT	ENDS
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 678  : 		if( psz == NULL )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _psz$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $L93419

; 683  : 	}

  00008	c3		 ret	 0
$L93419:

; 679  : 		{
; 680  : 			return( 0 );
; 681  : 		}
; 682  : 		return( int( strlen( psz ) ) );

  00009	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000c	8d 64 24 00	 npad	 4
$L93710:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $L93710
  00017	2b c2		 sub	 eax, edx

; 683  : 	}

  00019	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
; Function compile flags: /Ogty
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 510  : 		return( m_pszData );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 511  : 	}

  00002	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Ogty
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nChars$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _pchSrc$[esp]
  00009	8b c1		 mov	 eax, ecx
  0000b	57		 push	 edi
  0000c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pchDest$[esp+4]
  00010	c1 e9 02	 shr	 ecx, 2
  00013	f3 a5		 rep movsd
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	f3 a4		 rep movsb
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 654  : 	}

  0001e	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
EXTRN	_memmove:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 657  : 		memmove( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

  00000	e9 00 00 00 00	 jmp	 _memmove
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 e8 10	 sub	 eax, 16			; 00000010H

; 732  : 	}

  00005	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR _hr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 41   : 	}

  00008	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T93729 = 8						; size = 4
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	68 00 00 00 00	 push	 OFFSET FLAT:__TI1?AVCAtlException@ATL@@
  00009	8d 4c 24 08	 lea	 ecx, DWORD PTR $T93729[esp]
  0000d	51		 push	 ecx
  0000e	89 44 24 0c	 mov	 DWORD PTR $T93729[esp+4], eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$L93736:
$L93735:
  00017	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 66   : 		return (this+1);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 67   : 	}

  00003	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
; Function compile flags: /Ogty
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsLocked@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 76   : 		return nRefs < 0;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 9c c0	 setl	 al

; 77   : 	}

  0000a	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Ogty
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 80   : 		return( nRefs > 1 ); 

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	83 fa 01	 cmp	 edx, 1
  00008	0f 9f c0	 setg	 al

; 81   : 	}

  0000b	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Ogty
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 93   : 		ATLASSERT( nRefs != 0 );
; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	4a		 dec	 edx
  0000b	85 d2		 test	 edx, edx
  0000d	7f 0a		 jg	 SHORT $L73499

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	51		 push	 ecx
  00014	8b c8		 mov	 ecx, eax
  00016	ff 52 04	 call	 DWORD PTR [edx+4]
$L73499:

; 98   : 		}
; 99   : 	}

  00019	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCOverlappedEx@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCOverlappedEx@@UAEPAXI@Z PROC NEAR			; COverlappedEx::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7COverlappedEx@@6B@
  0000e	74 09		 je	 SHORT $L93755
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$L93755:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_GCOverlappedEx@@UAEPAXI@Z ENDP			; COverlappedEx::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CPacket@@QAE@XZ				; CPacket::CPacket
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tpatchsvr\packet.cpp
;	COMDAT ??0CPacket@@QAE@XZ
_TEXT	SEGMENT
??0CPacket@@QAE@XZ PROC NEAR				; CPacket::CPacket, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 23   : 	m_dwBufferSize = 0;

  00005	33 ed		 xor	 ebp, ebp

; 24   : 	m_pHeader = NULL;
; 25   : 	m_pBuf = NULL;
; 26   : 	m_bType = PACKET_SEND;
; 27   : 
; 28   : 	ExpandIoBuffer(-1);

  00007	6a ff		 push	 -1
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CPacket@@6B@
  0000f	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  00012	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00015	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00018	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1
  0001c	e8 00 00 00 00	 call	 ?ExpandIoBuffer@CPacket@@QAEKK@Z ; CPacket::ExpandIoBuffer

; 29   : 	Clear();

  00021	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00024	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00027	8b d1		 mov	 edx, ecx
  00029	c1 e9 02	 shr	 ecx, 2
  0002c	33 c0		 xor	 eax, eax
  0002e	f3 ab		 rep stosd
  00030	8b ca		 mov	 ecx, edx
  00032	83 e1 03	 and	 ecx, 3
  00035	f3 aa		 rep stosb
  00037	80 7e 18 01	 cmp	 BYTE PTR [esi+24], 1
  0003b	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  0003e	75 08		 jne	 SHORT $L93762
  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	66 c7 00 08 00	 mov	 WORD PTR [eax], 8
$L93762:
  00048	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0004b	83 c1 08	 add	 ecx, 8
  0004e	5f		 pop	 edi
  0004f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 30   : }

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??0CPacket@@QAE@XZ ENDP					; CPacket::CPacket
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCPacket@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPacket@@UAEPAXI@Z PROC NEAR			; CPacket::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00006	85 c0		 test	 eax, eax
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CPacket@@6B@
  0000e	74 10		 je	 SHORT $L93771
  00010	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00013	85 c9		 test	 ecx, ecx
  00015	74 09		 je	 SHORT $L93771
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001d	83 c4 04	 add	 esp, 4
$L93771:
  00020	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00025	74 09		 je	 SHORT $L93772
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$L93772:
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	c2 04 00	 ret	 4
??_GCPacket@@UAEPAXI@Z ENDP				; CPacket::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Flush@CPacket@@QAEXXZ				; CPacket::Flush
; Function compile flags: /Ogty
;	COMDAT ?Flush@CPacket@@QAEXXZ
_TEXT	SEGMENT
?Flush@CPacket@@QAEXXZ PROC NEAR			; CPacket::Flush, COMDAT
; _this$ = ecx

; 91   : {

  00000	8b d1		 mov	 edx, ecx

; 92   : 	DWORD dwTrashSize = GetSize();

  00002	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00005	85 c0		 test	 eax, eax
  00007	74 05		 je	 SHORT $L93780
  00009	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000c	eb 05		 jmp	 SHORT $L93781
$L93780:
  0000e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93781:

; 93   : 
; 94   : 	if( m_dwReadBytes < dwTrashSize )

  00013	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00016	0f b7 c0	 movzx	 eax, ax
  00019	3b c8		 cmp	 ecx, eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 95   : 	{
; 96   : 		Clear();

  0001d	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  00020	73 34		 jae	 SHORT $L93019
  00022	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00025	8b f1		 mov	 esi, ecx
  00027	c1 e9 02	 shr	 ecx, 2
  0002a	33 c0		 xor	 eax, eax
  0002c	f3 ab		 rep stosd
  0002e	8b ce		 mov	 ecx, esi
  00030	83 e1 03	 and	 ecx, 3
  00033	f3 aa		 rep stosb
  00035	80 7a 18 01	 cmp	 BYTE PTR [edx+24], 1
  00039	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  00040	75 08		 jne	 SHORT $L93786
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	66 c7 00 08 00	 mov	 WORD PTR [eax], 8
$L93786:
  0004a	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0004d	83 c1 08	 add	 ecx, 8
  00050	5f		 pop	 edi
  00051	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00054	5e		 pop	 esi

; 104  : }

  00055	c3		 ret	 0
$L93019:

; 97   : 		return;
; 98   : 	}
; 99   : 
; 100  : 	m_dwReadBytes -= dwTrashSize;

  00056	2b c8		 sub	 ecx, eax

; 101  : 	m_ptrOffset = m_pBuf + PACKET_HEADER_SIZE;

  00058	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0005b	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  0005e	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 102  : 
; 103  : 	memcpy( m_pBuf, m_pBuf + dwTrashSize, m_dwReadBytes);

  00061	8b d1		 mov	 edx, ecx
  00063	c1 e9 02	 shr	 ecx, 2
  00066	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  00069	f3 a5		 rep movsd
  0006b	8b ca		 mov	 ecx, edx
  0006d	83 e1 03	 and	 ecx, 3
  00070	f3 a4		 rep movsb
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 104  : }

  00074	c3		 ret	 0
?Flush@CPacket@@QAEXXZ ENDP				; CPacket::Flush
_TEXT	ENDS
PUBLIC	?IsReadBufferFull@CPacket@@QAEHXZ		; CPacket::IsReadBufferFull
; Function compile flags: /Ogty
;	COMDAT ?IsReadBufferFull@CPacket@@QAEHXZ
_TEXT	SEGMENT
?IsReadBufferFull@CPacket@@QAEHXZ PROC NEAR		; CPacket::IsReadBufferFull, COMDAT
; _this$ = ecx

; 108  : 	return m_dwReadBytes >= PACKET_HEADER_SIZE && GetSize() > m_dwBufferSize;

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 21		 jb	 SHORT $L93790
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	85 c0		 test	 eax, eax
  0000b	74 05		 je	 SHORT $L93796
  0000d	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00010	eb 05		 jmp	 SHORT $L93797
$L93796:
  00012	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L93797:
  00017	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001a	0f b7 c0	 movzx	 eax, ax
  0001d	3b c2		 cmp	 eax, edx
  0001f	76 06		 jbe	 SHORT $L93790
  00021	b8 01 00 00 00	 mov	 eax, 1

; 109  : }

  00026	c3		 ret	 0
$L93790:

; 108  : 	return m_dwReadBytes >= PACKET_HEADER_SIZE && GetSize() > m_dwBufferSize;

  00027	33 c0		 xor	 eax, eax

; 109  : }

  00029	c3		 ret	 0
?IsReadBufferFull@CPacket@@QAEHXZ ENDP			; CPacket::IsReadBufferFull
_TEXT	ENDS
PUBLIC	?CanRead@CPacket@@QAEHK@Z			; CPacket::CanRead
; Function compile flags: /Ogty
;	COMDAT ?CanRead@CPacket@@QAEHK@Z
_TEXT	SEGMENT
_length$ = 8						; size = 4
?CanRead@CPacket@@QAEHK@Z PROC NEAR			; CPacket::CanRead, COMDAT
; _this$ = ecx

; 118  : 	DWORD dwReadBytes = DWORD(m_ptrOffset - m_pBuf) + length;

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b c2		 sub	 eax, edx
  00008	03 44 24 04	 add	 eax, DWORD PTR _length$[esp-4]

; 119  : 	WORD wPacketSize = GetSize();

  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	85 d2		 test	 edx, edx
  00011	74 05		 je	 SHORT $L93808
  00013	66 8b 12	 mov	 dx, WORD PTR [edx]
  00016	eb 05		 jmp	 SHORT $L93809
$L93808:
  00018	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L93809:

; 120  : 
; 121  : 	return m_dwBufferSize >= dwReadBytes && wPacketSize >= dwReadBytes;

  0001d	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00020	72 0f		 jb	 SHORT $L93802
  00022	0f b7 ca	 movzx	 ecx, dx
  00025	3b c8		 cmp	 ecx, eax
  00027	72 08		 jb	 SHORT $L93802
  00029	b8 01 00 00 00	 mov	 eax, 1

; 122  : }

  0002e	c2 04 00	 ret	 4
$L93802:

; 120  : 
; 121  : 	return m_dwBufferSize >= dwReadBytes && wPacketSize >= dwReadBytes;

  00031	33 c0		 xor	 eax, eax

; 122  : }

  00033	c2 04 00	 ret	 4
?CanRead@CPacket@@QAEHK@Z ENDP				; CPacket::CanRead
_TEXT	ENDS
PUBLIC	?CanWrite@CPacket@@QAEHK@Z			; CPacket::CanWrite
; Function compile flags: /Ogty
;	COMDAT ?CanWrite@CPacket@@QAEHK@Z
_TEXT	SEGMENT
_length$ = 8						; size = 4
?CanWrite@CPacket@@QAEHK@Z PROC NEAR			; CPacket::CanWrite, COMDAT
; _this$ = ecx

; 126  : 	return m_dwBufferSize >= GetSize() + length;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 15		 je	 SHORT $L93818
  00007	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000a	8b 54 24 04	 mov	 edx, DWORD PTR _length$[esp-4]
  0000e	0f b7 c0	 movzx	 eax, ax
  00011	03 c2		 add	 eax, edx
  00013	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00016	1b c0		 sbb	 eax, eax
  00018	40		 inc	 eax

; 127  : }

  00019	c2 04 00	 ret	 4

; 126  : 	return m_dwBufferSize >= GetSize() + length;

$L93818:
  0001c	8b 54 24 04	 mov	 edx, DWORD PTR _length$[esp-4]
  00020	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00025	0f b7 c0	 movzx	 eax, ax
  00028	03 c2		 add	 eax, edx
  0002a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0002d	1b c0		 sbb	 eax, eax
  0002f	40		 inc	 eax

; 127  : }

  00030	c2 04 00	 ret	 4
?CanWrite@CPacket@@QAEHK@Z ENDP				; CPacket::CanWrite
_TEXT	ENDS
PUBLIC	?Read@CPacket@@QAEXPAXH@Z			; CPacket::Read
; Function compile flags: /Ogty
;	COMDAT ?Read@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
_nLength$ = 12						; size = 4
?Read@CPacket@@QAEXPAXH@Z PROC NEAR			; CPacket::Read, COMDAT
; _this$ = ecx

; 148  : {

  00000	53		 push	 ebx

; 149  : 	if(CanRead(nLength))

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	8b d1		 mov	 edx, ecx
  00007	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0000a	56		 push	 esi
  0000b	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0000e	57		 push	 edi
  0000f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  00012	8b c6		 mov	 eax, esi
  00014	2b c7		 sub	 eax, edi
  00016	03 c3		 add	 eax, ebx
  00018	85 c9		 test	 ecx, ecx
  0001a	74 05		 je	 SHORT $L93838
  0001c	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0001f	eb 05		 jmp	 SHORT $L93839
$L93838:
  00021	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93839:
  00026	39 42 10	 cmp	 DWORD PTR [edx+16], eax
  00029	72 1e		 jb	 SHORT $L93054
  0002b	0f b7 c9	 movzx	 ecx, cx
  0002e	3b c8		 cmp	 ecx, eax
  00030	72 17		 jb	 SHORT $L93054

; 150  : 	{
; 151  : 		memcpy( param, m_ptrOffset, nLength);

  00032	8b 7c 24 10	 mov	 edi, DWORD PTR _param$[esp+8]
  00036	8b cb		 mov	 ecx, ebx
  00038	8b c1		 mov	 eax, ecx
  0003a	c1 e9 02	 shr	 ecx, 2
  0003d	f3 a5		 rep movsd
  0003f	8b c8		 mov	 ecx, eax
  00041	83 e1 03	 and	 ecx, 3
  00044	f3 a4		 rep movsb

; 152  : 		m_ptrOffset += nLength;

  00046	01 5a 08	 add	 DWORD PTR [edx+8], ebx
$L93054:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 153  : 	}
; 154  : }

  0004c	c2 08 00	 ret	 8
?Read@CPacket@@QAEXPAXH@Z ENDP				; CPacket::Read
_TEXT	ENDS
PUBLIC	?Write@CPacket@@QAEXPAXH@Z			; CPacket::Write
; Function compile flags: /Ogty
;	COMDAT ?Write@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
_nLength$ = 12						; size = 4
?Write@CPacket@@QAEXPAXH@Z PROC NEAR			; CPacket::Write, COMDAT
; _this$ = ecx

; 157  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 158  : 	if(m_pHeader->m_wSize >= MAX_PACKET_SIZE)

  00003	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00006	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00009	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  0000d	73 71		 jae	 SHORT $L93063

; 159  : 		return;
; 160  : 
; 161  : 	if(!CanWrite(nLength))

  0000f	85 c9		 test	 ecx, ecx
  00011	0f b7 c8	 movzx	 ecx, ax
  00014	75 05		 jne	 SHORT $L93861
  00016	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93861:
  0001b	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0001e	0f b7 c9	 movzx	 ecx, cx
  00021	55		 push	 ebp
  00022	8b 6c 24 10	 mov	 ebp, DWORD PTR _nLength$[esp+4]
  00026	03 cd		 add	 ecx, ebp
  00028	3b c1		 cmp	 eax, ecx
  0002a	73 19		 jae	 SHORT $L93061

; 162  : 		ExpandIoBuffer(m_dwBufferSize + max(nLength, DEF_PACKET_SIZE));

  0002c	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  00032	8b cd		 mov	 ecx, ebp
  00034	7f 05		 jg	 SHORT $L93849
  00036	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
$L93849:
  0003b	03 c1		 add	 eax, ecx
  0003d	50		 push	 eax
  0003e	8b cb		 mov	 ecx, ebx
  00040	e8 00 00 00 00	 call	 ?ExpandIoBuffer@CPacket@@QAEKK@Z ; CPacket::ExpandIoBuffer
$L93061:
  00045	56		 push	 esi

; 163  : 
; 164  : 	memcpy( m_ptrOffset, param, nLength);

  00046	8b 74 24 10	 mov	 esi, DWORD PTR _param$[esp+8]
  0004a	57		 push	 edi
  0004b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0004e	8b cd		 mov	 ecx, ebp
  00050	8b d1		 mov	 edx, ecx
  00052	c1 e9 02	 shr	 ecx, 2
  00055	f3 a5		 rep movsd
  00057	8b ca		 mov	 ecx, edx
  00059	83 e1 03	 and	 ecx, 3
  0005c	f3 a4		 rep movsb

; 165  : 	m_ptrOffset += nLength;

  0005e	01 6b 08	 add	 DWORD PTR [ebx+8], ebp

; 166  : 
; 167  : 	if(m_pHeader->m_wSize + nLength > MAX_PACKET_SIZE)

  00061	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00064	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00067	03 c5		 add	 eax, ebp
  00069	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	7e 0a		 jle	 SHORT $L93062
  00072	5d		 pop	 ebp

; 168  : 		m_pHeader->m_wSize = MAX_PACKET_SIZE;

  00073	66 c7 03 ff ff	 mov	 WORD PTR [ebx], 65535	; 0000ffffH
  00078	5b		 pop	 ebx

; 171  : }

  00079	c2 08 00	 ret	 8
$L93062:

; 169  : 	else
; 170  : 		m_pHeader->m_wSize += nLength;

  0007c	66 01 2b	 add	 WORD PTR [ebx], bp
  0007f	5d		 pop	 ebp
$L93063:
  00080	5b		 pop	 ebx

; 171  : }

  00081	c2 08 00	 ret	 8
?Write@CPacket@@QAEXPAXH@Z ENDP				; CPacket::Write
_TEXT	ENDS
PUBLIC	?DetachBinary@CPacket@@QAEHPAPAX@Z		; CPacket::DetachBinary
; Function compile flags: /Ogty
;	COMDAT ?DetachBinary@CPacket@@QAEHPAPAX@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
_ptr$ = 8						; size = 4
?DetachBinary@CPacket@@QAEHPAPAX@Z PROC NEAR		; CPacket::DetachBinary, COMDAT
; _this$ = ecx

; 224  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx

; 225  : 	int nLength;
; 226  : 
; 227  : 	Read( &nLength, sizeof(DWORD));

  00005	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00008	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0000b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000e	8b c2		 mov	 eax, edx
  00010	2b c3		 sub	 eax, ebx
  00012	83 c0 04	 add	 eax, 4
  00015	85 c9		 test	 ecx, ecx
  00017	57		 push	 edi
  00018	74 05		 je	 SHORT $L93895
  0001a	66 8b 39	 mov	 di, WORD PTR [ecx]
  0001d	eb 05		 jmp	 SHORT $L93896
$L93895:
  0001f	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
$L93896:
  00024	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  00027	3b e8		 cmp	 ebp, eax
  00029	72 11		 jb	 SHORT $L93926
  0002b	0f b7 ff	 movzx	 edi, di
  0002e	3b f8		 cmp	 edi, eax
  00030	72 0a		 jb	 SHORT $L93926
  00032	8b 3a		 mov	 edi, DWORD PTR [edx]
  00034	83 c2 04	 add	 edx, 4
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	eb 04		 jmp	 SHORT $L93902
$L93926:
  0003c	8b 7c 24 14	 mov	 edi, DWORD PTR _nLength$[esp+12]
$L93902:

; 228  : 	if( nLength <= 0 || !CanRead(nLength) )

  00040	85 ff		 test	 edi, edi
  00042	7e 41		 jle	 SHORT $L93101
  00044	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00047	2b c3		 sub	 eax, ebx
  00049	03 c7		 add	 eax, edi
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 05		 je	 SHORT $L93918
  0004f	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00052	eb 05		 jmp	 SHORT $L93919
$L93918:
  00054	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L93919:
  00059	3b e8		 cmp	 ebp, eax
  0005b	72 28		 jb	 SHORT $L93101
  0005d	0f b7 c9	 movzx	 ecx, cx
  00060	3b c8		 cmp	 ecx, eax
  00062	72 21		 jb	 SHORT $L93101

; 232  : 	}
; 233  : 
; 234  : 	*ptr = new BYTE[nLength];

  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0006a	8b 54 24 18	 mov	 edx, DWORD PTR _ptr$[esp+16]
  0006e	83 c4 04	 add	 esp, 4

; 235  : 	Read( *ptr, nLength);

  00071	57		 push	 edi
  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	89 02		 mov	 DWORD PTR [edx], eax
  00077	e8 00 00 00 00	 call	 ?Read@CPacket@@QAEXPAXH@Z ; CPacket::Read

; 236  : 
; 237  : 	return nLength;

  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5d		 pop	 ebp
  00081	5b		 pop	 ebx

; 238  : }

  00082	c2 04 00	 ret	 4
$L93101:

; 229  : 	{
; 230  : 		*ptr = NULL;

  00085	8b 44 24 14	 mov	 eax, DWORD PTR _ptr$[esp+12]
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 231  : 		return 0;

  00092	33 c0		 xor	 eax, eax
  00094	5b		 pop	 ebx

; 238  : }

  00095	c2 04 00	 ret	 4
?DetachBinary@CPacket@@QAEHPAPAX@Z ENDP			; CPacket::DetachBinary
_TEXT	ENDS
PUBLIC	?AttachBinary@CPacket@@QAEXPAXH@Z		; CPacket::AttachBinary
; Function compile flags: /Ogty
;	COMDAT ?AttachBinary@CPacket@@QAEXPAXH@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
_nLength$ = 12						; size = 4
?AttachBinary@CPacket@@QAEXPAXH@Z PROC NEAR		; CPacket::AttachBinary, COMDAT
; _this$ = ecx

; 241  : {

  00000	56		 push	 esi

; 242  : 	Write( &nLength, sizeof(int));

  00001	6a 04		 push	 4
  00003	8d 44 24 10	 lea	 eax, DWORD PTR _nLength$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 243  : 	Write( param, nLength);

  0000f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nLength$[esp]
  00013	8b 54 24 08	 mov	 edx, DWORD PTR _param$[esp]
  00017	51		 push	 ecx
  00018	52		 push	 edx
  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write
  00020	5e		 pop	 esi

; 244  : }

  00021	c2 08 00	 ret	 8
?AttachBinary@CPacket@@QAEXPAXH@Z ENDP			; CPacket::AttachBinary
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@K@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@K@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??6CPacket@@QAEAAV0@K@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 263  : {

  00000	56		 push	 esi

; 264  : 	Write( (LPVOID) &param, sizeof(DWORD));

  00001	6a 04		 push	 4
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 265  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 266  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@K@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@G@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@G@Z
_TEXT	SEGMENT
_param$ = 8						; size = 2
??6CPacket@@QAEAAV0@G@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 269  : {

  00000	56		 push	 esi

; 270  : 	Write( (LPVOID) &param, sizeof(WORD));

  00001	6a 02		 push	 2
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 271  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 272  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@G@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@PBD@Z			; CPacket::operator<<
EXTRN	__imp__lstrlenA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
_param$ = 8						; size = 4
??6CPacket@@QAEAAV0@PBD@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 275  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 276  : 	int nLength = lstrlen(param);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _param$[esp+4]
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0000f	89 44 24 0c	 mov	 DWORD PTR _nLength$[esp+4], eax

; 277  : 
; 278  : 	Write( (LPVOID) &nLength, sizeof(int));

  00013	6a 04		 push	 4
  00015	8d 44 24 10	 lea	 eax, DWORD PTR _nLength$[esp+8]
  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 279  : 	Write( (LPVOID) param, nLength);

  00021	8b 4c 24 0c	 mov	 ecx, DWORD PTR _nLength$[esp+4]
  00025	51		 push	 ecx
  00026	57		 push	 edi
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write
  0002e	5f		 pop	 edi

; 280  : 
; 281  : 	return *this;

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 282  : }

  00032	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@PBD@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@F@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@F@Z
_TEXT	SEGMENT
_param$ = 8						; size = 2
??6CPacket@@QAEAAV0@F@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 285  : {

  00000	56		 push	 esi

; 286  : 	Write( (LPVOID) &param, sizeof(short));

  00001	6a 02		 push	 2
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 287  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 288  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@F@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@J@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@J@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??6CPacket@@QAEAAV0@J@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 291  : {

  00000	56		 push	 esi

; 292  : 	Write( (LPVOID) &param, sizeof(long));

  00001	6a 04		 push	 4
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 293  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 294  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@J@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@H@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@H@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??6CPacket@@QAEAAV0@H@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 297  : {

  00000	56		 push	 esi

; 298  : 	Write( (LPVOID) &param, sizeof(int));

  00001	6a 04		 push	 4
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 299  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 300  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@H@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@D@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@D@Z
_TEXT	SEGMENT
_param$ = 8						; size = 1
??6CPacket@@QAEAAV0@D@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 303  : {

  00000	56		 push	 esi

; 304  : 	Write( (LPVOID) &param, sizeof(char));

  00001	6a 01		 push	 1
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 305  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 306  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@D@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@E@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@E@Z
_TEXT	SEGMENT
_param$ = 8						; size = 1
??6CPacket@@QAEAAV0@E@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 309  : {

  00000	56		 push	 esi

; 310  : 	Write( (LPVOID) &param, sizeof(BYTE));

  00001	6a 01		 push	 1
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 311  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 312  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@E@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@M@Z				; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@M@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??6CPacket@@QAEAAV0@M@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 315  : {

  00000	56		 push	 esi

; 316  : 	Write( (LPVOID)&param, sizeof(float));

  00001	6a 04		 push	 4
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 317  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 318  : }

  00012	c2 04 00	 ret	 4
??6CPacket@@QAEAAV0@M@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??6CPacket@@QAEAAV0@_J@Z			; CPacket::operator<<
; Function compile flags: /Ogty
;	COMDAT ??6CPacket@@QAEAAV0@_J@Z
_TEXT	SEGMENT
_param$ = 8						; size = 8
??6CPacket@@QAEAAV0@_J@Z PROC NEAR			; CPacket::operator<<, COMDAT
; _this$ = ecx

; 321  : {

  00000	56		 push	 esi

; 322  : 	Write( (LPVOID) &param, sizeof(__int64));

  00001	6a 08		 push	 8
  00003	8d 44 24 0c	 lea	 eax, DWORD PTR _param$[esp+4]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?Write@CPacket@@QAEXPAXH@Z ; CPacket::Write

; 323  : 	return *this;

  0000f	8b c6		 mov	 eax, esi
  00011	5e		 pop	 esi

; 324  : }

  00012	c2 08 00	 ret	 8
??6CPacket@@QAEAAV0@_J@Z ENDP				; CPacket::operator<<
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAK@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAK@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 327  : {

  00000	8b c1		 mov	 eax, ecx

; 328  : 	Read( (LPVOID) &param, sizeof(DWORD));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 04	 add	 ecx, 4
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L93989
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L93990
$L93989:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L93990:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 13		 jb	 SHORT $L93996
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0c		 jb	 SHORT $L93996
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	8b 16		 mov	 edx, DWORD PTR [esi]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	83 40 08 04	 add	 DWORD PTR [eax+8], 4
$L93996:
  00039	5e		 pop	 esi

; 329  : 	return *this;
; 330  : }

  0003a	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAK@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAG@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAG@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAG@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 333  : {

  00000	8b c1		 mov	 eax, ecx

; 334  : 	Read( (LPVOID) &param, sizeof(WORD));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 02	 add	 ecx, 2
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L94030
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L94031
$L94030:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94031:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 15		 jb	 SHORT $L94037
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0e		 jb	 SHORT $L94037
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	66 8b 16	 mov	 dx, WORD PTR [esi]
  00034	66 89 11	 mov	 WORD PTR [ecx], dx
  00037	83 40 08 02	 add	 DWORD PTR [eax+8], 2
$L94037:
  0003b	5e		 pop	 esi

; 335  : 	return *this;
; 336  : }

  0003c	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAG@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAF@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAF@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 358  : {

  00000	8b c1		 mov	 eax, ecx

; 359  : 	Read( (LPVOID) &param, sizeof(short));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 02	 add	 ecx, 2
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L94071
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L94072
$L94071:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94072:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 15		 jb	 SHORT $L94078
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0e		 jb	 SHORT $L94078
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	66 8b 16	 mov	 dx, WORD PTR [esi]
  00034	66 89 11	 mov	 WORD PTR [ecx], dx
  00037	83 40 08 02	 add	 DWORD PTR [eax+8], 2
$L94078:
  0003b	5e		 pop	 esi

; 360  : 	return *this;
; 361  : }

  0003c	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAF@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAJ@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAJ@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 364  : {

  00000	8b c1		 mov	 eax, ecx

; 365  : 	Read( (LPVOID) &param, sizeof(long));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 04	 add	 ecx, 4
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L94118
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L94119
$L94118:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94119:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 13		 jb	 SHORT $L94108
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0c		 jb	 SHORT $L94108
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	8b 16		 mov	 edx, DWORD PTR [esi]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	83 40 08 04	 add	 DWORD PTR [eax+8], 4
$L94108:
  00039	5e		 pop	 esi

; 366  : 	return *this;
; 367  : }

  0003a	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAJ@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAH@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAH@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 370  : {

  00000	8b c1		 mov	 eax, ecx

; 371  : 	Read( (LPVOID) &param, sizeof(int));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 04	 add	 ecx, 4
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L94159
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L94160
$L94159:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94160:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 13		 jb	 SHORT $L94149
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0c		 jb	 SHORT $L94149
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	8b 16		 mov	 edx, DWORD PTR [esi]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	83 40 08 04	 add	 DWORD PTR [eax+8], 4
$L94149:
  00039	5e		 pop	 esi

; 372  : 	return *this;
; 373  : }

  0003a	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAH@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAD@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAD@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAD@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 376  : {

  00000	8b c1		 mov	 eax, ecx

; 377  : 	Read( (LPVOID) &param, sizeof(char));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	41		 inc	 ecx
  00011	85 d2		 test	 edx, edx
  00013	74 05		 je	 SHORT $L94200
  00015	66 8b 12	 mov	 dx, WORD PTR [edx]
  00018	eb 05		 jmp	 SHORT $L94201
$L94200:
  0001a	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94201:
  0001f	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00022	72 12		 jb	 SHORT $L94190
  00024	0f b7 d2	 movzx	 edx, dx
  00027	3b d1		 cmp	 edx, ecx
  00029	72 0b		 jb	 SHORT $L94190
  0002b	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  0002f	8a 16		 mov	 dl, BYTE PTR [esi]
  00031	88 11		 mov	 BYTE PTR [ecx], dl
  00033	ff 40 08	 inc	 DWORD PTR [eax+8]
$L94190:
  00036	5e		 pop	 esi

; 378  : 	return *this;
; 379  : }

  00037	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAD@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAE@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAE@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAE@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 382  : {

  00000	8b c1		 mov	 eax, ecx

; 383  : 	Read( (LPVOID) &param, sizeof(BYTE));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	41		 inc	 ecx
  00011	85 d2		 test	 edx, edx
  00013	74 05		 je	 SHORT $L94235
  00015	66 8b 12	 mov	 dx, WORD PTR [edx]
  00018	eb 05		 jmp	 SHORT $L94236
$L94235:
  0001a	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94236:
  0001f	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00022	72 12		 jb	 SHORT $L94242
  00024	0f b7 d2	 movzx	 edx, dx
  00027	3b d1		 cmp	 edx, ecx
  00029	72 0b		 jb	 SHORT $L94242
  0002b	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  0002f	8a 16		 mov	 dl, BYTE PTR [esi]
  00031	88 11		 mov	 BYTE PTR [ecx], dl
  00033	ff 40 08	 inc	 DWORD PTR [eax+8]
$L94242:
  00036	5e		 pop	 esi

; 384  : 	return *this;
; 385  : }

  00037	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAE@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAM@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AAM@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAM@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 388  : {

  00000	8b c1		 mov	 eax, ecx

; 389  : 	Read( (LPVOID) &param, sizeof(float));

  00002	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00005	56		 push	 esi
  00006	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00009	8b ce		 mov	 ecx, esi
  0000b	2b ca		 sub	 ecx, edx
  0000d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00010	83 c1 04	 add	 ecx, 4
  00013	85 d2		 test	 edx, edx
  00015	74 05		 je	 SHORT $L94276
  00017	66 8b 12	 mov	 dx, WORD PTR [edx]
  0001a	eb 05		 jmp	 SHORT $L94277
$L94276:
  0001c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94277:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 13		 jb	 SHORT $L94283
  00026	0f b7 d2	 movzx	 edx, dx
  00029	3b d1		 cmp	 edx, ecx
  0002b	72 0c		 jb	 SHORT $L94283
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00031	8b 16		 mov	 edx, DWORD PTR [esi]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	83 40 08 04	 add	 DWORD PTR [eax+8], 4
$L94283:
  00039	5e		 pop	 esi

; 390  : 	return *this;
; 391  : }

  0003a	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAM@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AA_J@Z			; CPacket::operator>>
; Function compile flags: /Ogty
;	COMDAT ??5CPacket@@QAEAAV0@AA_J@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AA_J@Z PROC NEAR			; CPacket::operator>>, COMDAT
; _this$ = ecx

; 394  : {

  00000	8b c1		 mov	 eax, ecx

; 395  : 	Read( (LPVOID) &param, sizeof(__int64));

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	56		 push	 esi
  00006	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00009	8b ca		 mov	 ecx, edx
  0000b	2b ce		 sub	 ecx, esi
  0000d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00010	83 c1 08	 add	 ecx, 8
  00013	85 f6		 test	 esi, esi
  00015	74 05		 je	 SHORT $L94317
  00017	66 8b 36	 mov	 si, WORD PTR [esi]
  0001a	eb 05		 jmp	 SHORT $L94318
$L94317:
  0001c	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
$L94318:
  00021	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00024	72 19		 jb	 SHORT $L94324
  00026	0f b7 f6	 movzx	 esi, si
  00029	3b f1		 cmp	 esi, ecx
  0002b	72 12		 jb	 SHORT $L94324
  0002d	8b 32		 mov	 esi, DWORD PTR [edx]
  0002f	8b 4c 24 08	 mov	 ecx, DWORD PTR _param$[esp]
  00033	89 31		 mov	 DWORD PTR [ecx], esi
  00035	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00038	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003b	83 40 08 08	 add	 DWORD PTR [eax+8], 8
$L94324:
  0003f	5e		 pop	 esi

; 396  : 	return *this;
; 397  : }

  00040	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AA_J@Z ENDP				; CPacket::operator>>
_TEXT	ENDS
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 501  : 		return( GetData()->nDataLength );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]

; 502  : 	}

  00005	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Ogty
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pData$[esp-4]
  00004	83 c0 10	 add	 eax, 16			; 00000010H
  00007	89 01		 mov	 DWORD PTR [ecx], eax

; 713  : 	}

  00009	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
; Function compile flags: /Ogty
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 790  : 		ATLASSERT( nLength >= 0 );
; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L93458
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L93458

; 794  : 			AtlThrow(E_INVALIDARG);
; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 797  : 		m_pszData[nLength] = 0;

  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 798  : 	}

  00018	c2 04 00	 ret	 4
$L93458:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L94351:
$L94350:
  00025	cc		 int	 3
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Ogty
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 705  : 		AtlThrow( E_OUTOFMEMORY );

  00000	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00005	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L94356:
$L94355:
  0000a	cc		 int	 3
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
PUBLIC	?IsEOF@CPacket@@QAEHXZ				; CPacket::IsEOF
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tpatchsvr\packet.cpp
;	COMDAT ?IsEOF@CPacket@@QAEHXZ
_TEXT	SEGMENT
?IsEOF@CPacket@@QAEHXZ PROC NEAR			; CPacket::IsEOF, COMDAT
; _this$ = ecx

; 113  : 	return !CanRead(1);

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b c2		 sub	 eax, edx
  00008	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000b	40		 inc	 eax
  0000c	85 d2		 test	 edx, edx
  0000e	74 05		 je	 SHORT $L94374
  00010	66 8b 12	 mov	 dx, WORD PTR [edx]
  00013	eb 05		 jmp	 SHORT $L94375
$L94374:
  00015	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L94375:
  0001a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0001d	72 16		 jb	 SHORT $L94371
  0001f	0f b7 ca	 movzx	 ecx, dx
  00022	3b c8		 cmp	 ecx, eax
  00024	72 0f		 jb	 SHORT $L94371
  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	33 d2		 xor	 edx, edx
  0002d	85 c0		 test	 eax, eax
  0002f	0f 94 c2	 sete	 dl
  00032	8b c2		 mov	 eax, edx

; 114  : }

  00034	c3		 ret	 0

; 113  : 	return !CanRead(1);

$L94371:
  00035	33 c0		 xor	 eax, eax
  00037	33 d2		 xor	 edx, edx
  00039	85 c0		 test	 eax, eax
  0003b	0f 94 c2	 sete	 dl
  0003e	8b c2		 mov	 eax, edx

; 114  : }

  00040	c3		 ret	 0
?IsEOF@CPacket@@QAEHXZ ENDP				; CPacket::IsEOF
_TEXT	ENDS
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 422  : 		CStringData* pOldData = GetData();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 423  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 424  : 		if( pOldData->nDataLength == 0 )

  00005	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  00008	85 d2		 test	 edx, edx
  0000a	8d 41 f0	 lea	 eax, DWORD PTR [ecx-16]
  0000d	57		 push	 edi
  0000e	8b 38		 mov	 edi, DWORD PTR [eax]
  00010	74 4c		 je	 SHORT $L94416
  00012	53		 push	 ebx

; 425  : 		{
; 426  : 			return;
; 427  : 		}
; 428  : 
; 429  : 		if( pOldData->IsLocked() )

  00013	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00016	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  00019	85 db		 test	 ebx, ebx
  0001b	5b		 pop	 ebx
  0001c	7d 20		 jge	 SHORT $L93425

; 430  : 		{
; 431  : 			// Don't reallocate a locked buffer that's shrinking
; 432  : 			SetLength( 0 );

  0001e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00021	85 c0		 test	 eax, eax
  00023	7d 0a		 jge	 SHORT $L94402
  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L94418:
$L94402:
  0002f	c7 41 f4 00 00
	00 00		 mov	 DWORD PTR [ecx-12], 0
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	5f		 pop	 edi
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0
  0003c	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  0003d	c3		 ret	 0
$L93425:

; 433  : 		}
; 434  : 		else
; 435  : 		{
; 436  : 			pOldData->Release();

  0003e	83 c9 ff	 or	 ecx, -1
  00041	f0 0f c1 0a	 lock	  xadd	 DWORD PTR [edx], ecx
  00045	49		 dec	 ecx
  00046	85 c9		 test	 ecx, ecx
  00048	7f 08		 jg	 SHORT $L94408
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	50		 push	 eax
  0004f	ff 52 04	 call	 DWORD PTR [edx+4]
$L94408:

; 437  : 			CStringData* pNewData = pStringMgr->GetNilString();

  00052	8b 07		 mov	 eax, DWORD PTR [edi]
  00054	8b cf		 mov	 ecx, edi
  00056	ff 50 0c	 call	 DWORD PTR [eax+12]

; 438  : 			Attach( pNewData );

  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 06		 mov	 DWORD PTR [esi], eax
$L94416:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 439  : 		}
; 440  : 	}

  00060	c3		 ret	 0
$L94417:
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
; Function compile flags: /Ogty
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );
; 548  : 		SetLength( nNewLength );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nNewLength$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7c 13		 jl	 SHORT $L94436
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  0000d	7f 0c		 jg	 SHORT $L94436
  0000f	89 42 f4	 mov	 DWORD PTR [edx-12], eax
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 549  : 	}

  00018	c2 04 00	 ret	 4
$L94436:
  0001b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00020	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L94439:
$L94438:
  00025	cc		 int	 3
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
; Function compile flags: /Ogty
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv181 = 8						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 716  : 		CStringData* pOldData = GetData();

  00002	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00004	83 eb 10	 sub	 ebx, 16			; 00000010H
  00007	55		 push	 ebp

; 717  : 		int nOldLength = pOldData->nDataLength;

  00008	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000b	89 4c 24 08	 mov	 DWORD PTR _this$[esp+12], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  0000f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	56		 push	 esi
  00014	ff 50 10	 call	 DWORD PTR [eax+16]
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _nLength$[esp+12]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	6a 01		 push	 1
  0001f	56		 push	 esi
  00020	8b c8		 mov	 ecx, eax
  00022	ff 12		 call	 DWORD PTR [edx]

; 719  : 		if( pNewData == NULL )

  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $L93477

; 720  : 		{
; 721  : 			ThrowMemoryException();

  00028	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L94470:
$L93477:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  0002d	3b ee		 cmp	 ebp, esi
  0002f	7d 02		 jge	 SHORT $L94444
  00031	8b f5		 mov	 esi, ebp
$L94444:
  00033	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

  00036	8b d1		 mov	 edx, ecx
  00038	57		 push	 edi
  00039	c1 e9 02	 shr	 ecx, 2
  0003c	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  0003f	89 7c 24 18	 mov	 DWORD PTR tv181[esp+16], edi
  00043	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00046	f3 a5		 rep movsd
  00048	8b ca		 mov	 ecx, edx
  0004a	83 e1 03	 and	 ecx, 3
  0004d	f3 a4		 rep movsb

; 725  : 		pNewData->nDataLength = nOldLength;

  0004f	89 68 04	 mov	 DWORD PTR [eax+4], ebp

; 726  : 		pOldData->Release();

  00052	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00055	83 c9 ff	 or	 ecx, -1
  00058	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0005c	49		 dec	 ecx
  0005d	85 c9		 test	 ecx, ecx
  0005f	5f		 pop	 edi
  00060	7f 08		 jg	 SHORT $L94460
  00062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	53		 push	 ebx
  00067	ff 52 04	 call	 DWORD PTR [edx+4]
$L94460:

; 727  : 		Attach( pNewData );

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR tv181[esp+12]
  0006e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	89 01		 mov	 DWORD PTR [ecx], eax
  00076	5b		 pop	 ebx

; 728  : 	}

  00077	59		 pop	 ecx
  00078	c2 04 00	 ret	 4
$L94469:
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Ogty
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi

; 777  : 		CStringData* pOldData = GetData();
; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;
; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _nLength$[esp+4]
  00006	8b f1		 mov	 esi, ecx
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	83 e8 10	 sub	 eax, 16			; 00000010H
  00012	6a 01		 push	 1
  00014	57		 push	 edi
  00015	50		 push	 eax
  00016	ff 52 08	 call	 DWORD PTR [edx+8]

; 781  : 		if( pNewData == NULL )

  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L93486

; 782  : 		{
; 783  : 			ThrowMemoryException();

  0001d	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L94486:
$L93486:

; 784  : 		}
; 785  : 		Attach( pNewData );

  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	5f		 pop	 edi
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	5e		 pop	 esi

; 786  : 	}

  00029	c2 04 00	 ret	 4
$L94485:
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 747  : 		CStringData* pOldData = GetData();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 748  : 		if( pOldData->nDataLength > nLength )

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _nLength$[esp-4]
  00006	83 e8 10	 sub	 eax, 16			; 00000010H
  00009	56		 push	 esi
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	3b f2		 cmp	 esi, edx
  0000f	7e 02		 jle	 SHORT $L93463

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

  00011	8b d6		 mov	 edx, esi
$L93463:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

  00013	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00017	5e		 pop	 esi
  00018	7e 09		 jle	 SHORT $L93464

; 753  : 		{
; 754  : 			Fork( nLength );

  0001a	89 54 24 04	 mov	 DWORD PTR _nLength$[esp-4], edx
  0001e	e9 00 00 00 00	 jmp	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork
$L93464:

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

  00023	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00026	3b c2		 cmp	 eax, edx
  00028	7d 1f		 jge	 SHORT $L93466

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;
; 760  : 			if( nNewLength > 1024 )

  0002a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0002f	7e 07		 jle	 SHORT $L93468

; 761  : 			{
; 762  : 				nNewLength += 1024;

  00031	05 00 04 00 00	 add	 eax, 1024		; 00000400H

; 763  : 			}
; 764  : 			else

  00036	eb 02		 jmp	 SHORT $L93469
$L93468:

; 765  : 			{
; 766  : 				nNewLength *= 2;

  00038	03 c0		 add	 eax, eax
$L93469:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

  0003a	3b c2		 cmp	 eax, edx
  0003c	7d 02		 jge	 SHORT $L93470

; 769  : 			{
; 770  : 				nNewLength = nLength;

  0003e	8b c2		 mov	 eax, edx
$L93470:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

  00040	89 44 24 04	 mov	 DWORD PTR _nLength$[esp-4], eax
  00044	e9 00 00 00 00	 jmp	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L93466:

; 773  : 		}
; 774  : 	}

  00049	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Ogty
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 735  : 		CStringData* pOldData = GetData();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nLength$[esp]
  00019	2b d0		 sub	 edx, eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L94502

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L94502:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 744  : 	}

  0002a	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00008	83 e8 10	 sub	 eax, 16			; 00000010H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	2b ca		 sub	 ecx, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	8b 44 24 08	 mov	 eax, DWORD PTR _nMinBufferLength$[esp]
  00019	2b d0		 sub	 edx, eax
  0001b	0b ca		 or	 ecx, edx
  0001d	7d 08		 jge	 SHORT $L94519
  0001f	50		 push	 eax
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L94519:
  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5e		 pop	 esi

; 491  : 	}

  0002a	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 583  : 	{

  00000	53		 push	 ebx

; 584  : 		if( nLength == 0 )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _nLength$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	8b e9		 mov	 ebp, ecx
  0000a	75 0a		 jne	 SHORT $L93409

; 585  : 		{
; 586  : 			Empty();

  0000c	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty
  00011	5d		 pop	 ebp
  00012	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00013	c2 08 00	 ret	 8
$L93409:

; 587  : 		}
; 588  : 		else
; 589  : 		{
; 590  : 			// It is possible that pszSrc points to a location inside of our 
; 591  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer 
; 592  : 			// is shared or (2) the buffer is too small to hold the new 
; 593  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 594  : 			// into the newly allocated buffer instead.
; 595  : 			
; 596  : 			if(pszSrc == NULL)

  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSrc$[esp+4]
  0001a	85 d2		 test	 edx, edx
  0001c	75 0a		 jne	 SHORT $L93411

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

$L94587:
  0001e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00023	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L94595:
$L93411:

; 597  : 				AtlThrow(E_INVALIDARG);			
; 598  : 				
; 599  : 			UINT nOldLength = GetLength();

  00028	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0002b	56		 push	 esi

; 600  : 			UINT_PTR nOffset = pszSrc-GetString();

  0002c	8b f2		 mov	 esi, edx
  0002e	2b f0		 sub	 esi, eax

; 601  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our 
; 602  : 			// buffer
; 603  : 
; 604  : 			PXSTR pszBuffer = GetBuffer( nLength );

  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  00038	57		 push	 edi
  00039	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]
  0003c	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0003f	2b c3		 sub	 eax, ebx
  00041	0b c8		 or	 ecx, eax
  00043	7d 0c		 jge	 SHORT $L94556
  00045	53		 push	 ebx
  00046	8b cd		 mov	 ecx, ebp
  00048	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
  0004d	8b 54 24 14	 mov	 edx, DWORD PTR _pszSrc$[esp+12]
$L94556:

; 605  : 			if( nOffset <= nOldLength )

  00051	3b f7		 cmp	 esi, edi
  00053	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00056	77 10		 ja	 SHORT $L93416

; 606  : 			{
; 607  : 				CopyCharsOverlapped( pszBuffer, pszBuffer+nOffset, nLength );

  00058	53		 push	 ebx
  00059	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005c	51		 push	 ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memmove
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 			}
; 609  : 			else

  00066	eb 14		 jmp	 SHORT $L94564
$L93416:

; 610  : 			{
; 611  : 				CopyChars( pszBuffer, pszSrc, nLength );

  00068	8b cb		 mov	 ecx, ebx
  0006a	8b f2		 mov	 esi, edx
  0006c	8b d1		 mov	 edx, ecx
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	8b f8		 mov	 edi, eax
  00073	f3 a5		 rep movsd
  00075	8b ca		 mov	 ecx, edx
  00077	83 e1 03	 and	 ecx, 3
  0007a	f3 a4		 rep movsb
$L94564:

; 612  : 			}
; 613  : 			ReleaseBufferSetLength( nLength );

  0007c	85 db		 test	 ebx, ebx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	7c 9c		 jl	 SHORT $L94587
  00082	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00085	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  00088	7f 94		 jg	 SHORT $L94587
  0008a	89 58 f4	 mov	 DWORD PTR [eax-12], ebx
  0008d	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00090	5d		 pop	 ebp
  00091	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  00095	5b		 pop	 ebx

; 614  : 		}
; 615  : 	}

  00096	c2 08 00	 ret	 8
$L94594:
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
; Function compile flags: /Ogty
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 579  : 	{

  00000	56		 push	 esi

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pszSrc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 0d		 jne	 SHORT $L94601
  00009	33 c0		 xor	 eax, eax
  0000b	50		 push	 eax
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00012	5e		 pop	 esi

; 581  : 	}

  00013	c2 04 00	 ret	 4

; 580  : 		SetString( pszSrc, StringLength( pszSrc ) );

$L94601:
  00016	8b c6		 mov	 eax, esi
  00018	57		 push	 edi
  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001c	8d 64 24 00	 npad	 4
$L94604:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 d2		 test	 dl, dl
  00025	75 f9		 jne	 SHORT $L94604
  00027	2b c7		 sub	 eax, edi
  00029	5f		 pop	 edi
  0002a	50		 push	 eax
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
  00031	5e		 pop	 esi

; 581  : 	}

  00032	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
; Function compile flags: /Ogty
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 316  : 		SetString( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L94617
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 319  : 	}

  00017	c2 04 00	 ret	 4

; 316  : 		SetString( pszSrc );

$L94617:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L94619:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L94619
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 317  : 
; 318  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 319  : 	}

  00036	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
PUBLIC	??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 983  : 		CThisSimpleString::operator=( pszSrc );

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pszSrc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	75 0f		 jne	 SHORT $L94640
  0000b	33 c0		 xor	 eax, eax
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00014	8b c7		 mov	 eax, edi
  00016	5f		 pop	 edi

; 986  : 	}

  00017	c2 04 00	 ret	 4

; 983  : 		CThisSimpleString::operator=( pszSrc );

$L94640:
  0001a	8b c2		 mov	 eax, edx
  0001c	56		 push	 esi
  0001d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L94642:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $L94642
  00027	2b c6		 sub	 eax, esi
  00029	5e		 pop	 esi
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 984  : 
; 985  : 		return( *this );

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi

; 986  : 	}

  00036	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
PUBLIC	??5CPacket@@QAEAAV0@AAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z ; CPacket::operator>>
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tpatchsvr\packet.cpp
;	COMDAT ??5CPacket@@QAEAAV0@AAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z
_TEXT	SEGMENT
_nLength$ = 8						; size = 4
_param$ = 8						; size = 4
??5CPacket@@QAEAAV0@AAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z PROC NEAR ; CPacket::operator>>, COMDAT
; _this$ = ecx

; 339  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx

; 340  : 	int nLength;
; 341  : 
; 342  : 	Read( (LPVOID) &nLength, sizeof(int));

  00005	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00008	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000b	57		 push	 edi
  0000c	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  0000f	8b c2		 mov	 eax, edx
  00011	2b c7		 sub	 eax, edi
  00013	83 c0 04	 add	 eax, 4
  00016	85 c9		 test	 ecx, ecx
  00018	74 05		 je	 SHORT $L94674
  0001a	66 8b 29	 mov	 bp, WORD PTR [ecx]
  0001d	eb 05		 jmp	 SHORT $L94675
$L94674:
  0001f	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
$L94675:
  00024	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00027	3b d8		 cmp	 ebx, eax
  00029	72 11		 jb	 SHORT $L94737
  0002b	0f b7 ed	 movzx	 ebp, bp
  0002e	3b e8		 cmp	 ebp, eax
  00030	72 0a		 jb	 SHORT $L94737
  00032	8b 2a		 mov	 ebp, DWORD PTR [edx]
  00034	83 c2 04	 add	 edx, 4
  00037	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003a	eb 04		 jmp	 SHORT $L94681
$L94737:
  0003c	8b 6c 24 14	 mov	 ebp, DWORD PTR _nLength$[esp+12]
$L94681:

; 343  : 	if(CanRead(nLength))

  00040	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00043	2b c7		 sub	 eax, edi
  00045	03 c5		 add	 eax, ebp
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $L94697
  0004b	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0004e	eb 05		 jmp	 SHORT $L94698
$L94697:
  00050	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L94698:
  00055	3b d8		 cmp	 ebx, eax
  00057	72 5c		 jb	 SHORT $L94736
  00059	0f b7 c9	 movzx	 ecx, cx
  0005c	3b c8		 cmp	 ecx, eax
  0005e	72 55		 jb	 SHORT $L94736

; 344  : 	{
; 345  : 		LPTSTR buff = new char[nLength + 1];

  00060	8d 7d 01	 lea	 edi, DWORD PTR [ebp+1]
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 346  : 
; 347  : 		memset( buff, '\0', nLength + 1);

  00069	8b cf		 mov	 ecx, edi
  0006b	8b d1		 mov	 edx, ecx
  0006d	8b d8		 mov	 ebx, eax
  0006f	c1 e9 02	 shr	 ecx, 2
  00072	33 c0		 xor	 eax, eax
  00074	8b fb		 mov	 edi, ebx
  00076	f3 ab		 rep stosd
  00078	83 c4 04	 add	 esp, 4
  0007b	8b ca		 mov	 ecx, edx
  0007d	83 e1 03	 and	 ecx, 3

; 348  : 		Read( buff, nLength);

  00080	55		 push	 ebp
  00081	f3 aa		 rep stosb
  00083	53		 push	 ebx
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?Read@CPacket@@QAEXPAXH@Z ; CPacket::Read

; 349  : 		param = buff;

  0008b	85 db		 test	 ebx, ebx
  0008d	75 04		 jne	 SHORT $L94730
  0008f	33 c0		 xor	 eax, eax
  00091	eb 0e		 jmp	 SHORT $L94729
$L94730:
  00093	8b c3		 mov	 eax, ebx
  00095	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L94734:
  00098	8a 08		 mov	 cl, BYTE PTR [eax]
  0009a	40		 inc	 eax
  0009b	84 c9		 test	 cl, cl
  0009d	75 f9		 jne	 SHORT $L94734
  0009f	2b c2		 sub	 eax, edx
$L94729:
  000a1	8b 4c 24 14	 mov	 ecx, DWORD PTR _param$[esp+12]
  000a5	50		 push	 eax
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 350  : 
; 351  : 		delete[] buff;

  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000b2	83 c4 04	 add	 esp, 4
$L94736:
  000b5	5f		 pop	 edi

; 352  : 	}
; 353  : 
; 354  : 	return *this;

  000b6	8b c6		 mov	 eax, esi
  000b8	5e		 pop	 esi
  000b9	5d		 pop	 ebp
  000ba	5b		 pop	 ebx

; 355  : }

  000bb	c2 04 00	 ret	 4
??5CPacket@@QAEAAV0@AAV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@@Z ENDP ; CPacket::operator>>
_TEXT	ENDS
END
