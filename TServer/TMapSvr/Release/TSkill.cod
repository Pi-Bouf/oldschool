; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\TSkill.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CTSkill@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCTSkill@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTSkill@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMaintain@CTSkill@@QAEXKEKEEGEKKKKEEMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CTSkill@@QAEXEKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReuseDelay@CTSkill@@QAEKEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRemainTick@CTSkill@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReuseRemainTick@CTSkill@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProb@CTSkill@@QAEEPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValue@CTSkill@@QAEKPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValue@CTSkill@@QAEKEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEndTick@CTSkill@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLoopEndTick@CTSkill@@QAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaintainTick@CTSkill@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcAbilityValue@CTSkill@@QAEHEKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcCure@CTSkill@@QAEHPAV1@KE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRequiredHP@CTSkill@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRequiredMP@CTSkill@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetID@CTSkill@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanUse@CTSkill@@QAEEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextLevel@CTSkill@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEnd@CTSkill@@QAEEK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBlood@CTSkill@@QAEKKE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAggro@CTSkill@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCountMultiAttack@CTSkill@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextSkillPoint@CTSkill@@QAEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUsedSkillPoint@CTSkill@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckParentSkill@CTSkill@@QAEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAPAUtagTSKILLDATA@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEAAPAUtagTSKILLDATA@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEABQAUtagTSKILLDATA@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@GIG@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagTAICONDITION@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagTAICONDITION@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagTAICONDITION@@V?$allocator@PAUtagTAICONDITION@@@std@@@std@@YAXPAPAUtagTAICONDITION@@0AAV?$allocator@PAUtagTAICONDITION@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagTMONITEM@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagTMONITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagTMONITEM@@V?$allocator@PAUtagTMONITEM@@@std@@@std@@YAXPAPAUtagTMONITEM@@0AAV?$allocator@PAUtagTMONITEM@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagTMAPMON@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagTMAPMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagTMAPMON@@V?$allocator@PAUtagTMAPMON@@@std@@@std@@YAXPAPAUtagTMAPMON@@0AAV?$allocator@PAUtagTMAPMON@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagPATHPOINT@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagPATHPOINT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagPATHPOINT@@V?$allocator@PAUtagPATHPOINT@@@std@@@std@@YAXPAPAUtagPATHPOINT@@0AAV?$allocator@PAUtagPATHPOINT@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagQUESTCONDITION@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagQUESTCONDITION@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagQUESTCONDITION@@V?$allocator@PAUtagQUESTCONDITION@@@std@@@std@@YAXPAPAUtagQUESTCONDITION@@0AAV?$allocator@PAUtagQUESTCONDITION@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagQUESTREWARD@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagQUESTREWARD@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagQUESTREWARD@@V?$allocator@PAUtagQUESTREWARD@@@std@@@std@@YAXPAPAUtagQUESTREWARD@@0AAV?$allocator@PAUtagQUESTREWARD@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@UtagQUESTTERM@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtagQUESTTERM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUtagQUESTTERM@@V?$allocator@PAUtagQUESTTERM@@@std@@@std@@YAXPAPAUtagQUESTTERM@@0AAV?$allocator@PAUtagQUESTTERM@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagTCASHITMSALE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagTCASHITMSALE@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagTCASHITMSALE@@IU1@V?$allocator@UtagTCASHITMSALE@@@std@@@std@@YAXPAUtagTCASHITMSALE@@IABU1@AAV?$allocator@UtagTCASHITMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagMONREGEN@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagMONREGEN@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagMONREGEN@@IU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAXPAUtagMONREGEN@@IABU1@AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagLOTTERY@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagLOTTERY@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUtagLOTTERY@@IU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAXPAUtagLOTTERY@@IABU1@AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@GV?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAGPAG@std@@YAPAGPAG00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VCTPlayer@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTPlayer@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVCTPlayer@@V?$allocator@PAVCTPlayer@@@std@@@std@@YAXPAPAVCTPlayer@@0AAV?$allocator@PAVCTPlayer@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagTCASHITMSALE@@V?$allocator@UtagTCASHITMSALE@@@std@@@std@@YAXPAUtagTCASHITMSALE@@0AAV?$allocator@UtagTCASHITMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagTCASHITMSALE@@PAU1@V?$allocator@UtagTCASHITMSALE@@@std@@@std@@YAPAUtagTCASHITMSALE@@PAU1@00AAV?$allocator@UtagTCASHITMSALE@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagTCASHITMSALE@@PAU1@@std@@YAPAUtagTCASHITMSALE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagMONREGEN@@V?$allocator@UtagMONREGEN@@@std@@@std@@YAXPAUtagMONREGEN@@0AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagMONREGEN@@PAU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAPAUtagMONREGEN@@PAU1@00AAV?$allocator@UtagMONREGEN@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagMONREGEN@@PAU1@@std@@YAPAUtagMONREGEN@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagLOTTERY@@V?$allocator@UtagLOTTERY@@@std@@@std@@YAXPAUtagLOTTERY@@0AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUtagLOTTERY@@PAU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAPAUtagLOTTERY@@PAU1@00AAV?$allocator@UtagLOTTERY@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUtagLOTTERY@@PAU1@@std@@YAPAUtagLOTTERY@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagTCASHITMSALE@@@std@@QAEXPAUtagTCASHITMSALE@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagTCASHITMSALE@@@std@@QAEXPAUtagTCASHITMSALE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagMONREGEN@@@std@@QAEXPAUtagMONREGEN@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagMONREGEN@@@std@@QAEXPAUtagMONREGEN@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UtagLOTTERY@@@std@@QAEXPAUtagLOTTERY@@ABU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagLOTTERY@@@std@@QAEXPAUtagLOTTERY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAGIG@std@@YAXPAGIABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@GG@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagTCASHITMSALE@@PAU1@V?$allocator@UtagTCASHITMSALE@@@std@@@std@@YAPAUtagTCASHITMSALE@@PAU1@00AAV?$allocator@UtagTCASHITMSALE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagMONREGEN@@PAU1@V?$allocator@UtagMONREGEN@@@std@@@std@@YAPAUtagMONREGEN@@PAU1@00AAV?$allocator@UtagMONREGEN@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUtagLOTTERY@@PAU1@V?$allocator@UtagLOTTERY@@@std@@@std@@YAPAUtagLOTTERY@@PAU1@00AAV?$allocator@UtagLOTTERY@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagTCASHITMSALE@@U1@@std@@YAXPAUtagTCASHITMSALE@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagTCASHITMSALE@@@std@@YAXPAUtagTCASHITMSALE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagMONREGEN@@U1@@std@@YAXPAUtagMONREGEN@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagMONREGEN@@@std@@YAXPAUtagMONREGEN@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UtagLOTTERY@@U1@@std@@YAXPAUtagLOTTERY@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagLOTTERY@@@std@@YAXPAUtagLOTTERY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CTSkill@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CTSkill@@QAE@XZ				; CTSkill::CTSkill
PUBLIC	??_7CTSkill@@6B@				; CTSkill::`vftable'
PUBLIC	??_GCTSkill@@UAEPAXI@Z				; CTSkill::`scalar deleting destructor'
EXTRN	__fltused:NEAR
EXTRN	??_ECTSkill@@UAEPAXI@Z:NEAR			; CTSkill::`vector deleting destructor'
;	COMDAT ??_7CTSkill@@6B@
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tmapsvr\tskill.cpp
CONST	SEGMENT
??_7CTSkill@@6B@ DD FLAT:??_ECTSkill@@UAEPAXI@Z		; CTSkill::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CTSkill@@QAE@XZ
_TEXT	SEGMENT
??0CTSkill@@QAE@XZ PROC NEAR				; CTSkill::CTSkill, COMDAT
; _this$ = ecx

; 4    : {

  00000	8b c1		 mov	 eax, ecx

; 5    : 	m_dwChargeTick = 0;

  00002	33 c9		 xor	 ecx, ecx

; 6    : 	m_dwUseTick = 0;
; 7    : 	m_dwDelayTick = 0;
; 8    : 	m_dwStartTick = 0;
; 9    : 	m_dwMaintainTick = 0;
; 10   : 	m_pTSKILL = NULL;
; 11   : 	m_bLevel = 1;

  00004	ba 01 00 00 00	 mov	 edx, 1
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CTSkill@@6B@
  0000f	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00012	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00015	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00018	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  0001b	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0001e	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  00021	88 50 50	 mov	 BYTE PTR [eax+80], dl

; 12   : 	m_dwAttackID = 0;

  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 13   : 	m_bAttackType = OT_PC;

  00027	88 50 08	 mov	 BYTE PTR [eax+8], dl

; 14   : 	m_dwHostID = 0;

  0002a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 15   : 	m_bHostType = OT_PC;

  0002d	88 50 10	 mov	 BYTE PTR [eax+16], dl

; 16   : 	m_bHit = HT_NORMAL;

  00030	88 50 11	 mov	 BYTE PTR [eax+17], dl

; 17   : 	m_wAttackLevel = 1;

  00033	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 18   : 	m_bAttackerLevel = 1;

  00037	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 19   : 	m_dwPysMinPower = 0;

  0003a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 20   : 	m_dwPysMaxPower = 0;

  0003d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 21   : 	m_dwMgMinPower = 0;

  00040	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 22   : 	m_dwMgMaxPower = 0;

  00043	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 23   : 	m_bCanSelect = TRUE;

  00046	88 50 28	 mov	 BYTE PTR [eax+40], dl

; 24   : 	m_wSilencedSkill = 0;

  00049	66 89 48 38	 mov	 WORD PTR [eax+56], cx

; 25   : 
; 26   : 	m_bAttackCountry = TCONTRY_N;

  0004d	c6 40 29 03	 mov	 BYTE PTR [eax+41], 3

; 27   : 	m_fPosX = 0;

  00051	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 28   : 	m_fPosY = 0;

  00054	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 29   : 	m_fPosZ = 0;

  00057	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 30   : }

  0005a	c3		 ret	 0
??0CTSkill@@QAE@XZ ENDP					; CTSkill::CTSkill
_TEXT	ENDS
PUBLIC	??1CTSkill@@UAE@XZ				; CTSkill::~CTSkill
; Function compile flags: /Ogty
;	COMDAT ??1CTSkill@@UAE@XZ
_TEXT	SEGMENT
??1CTSkill@@UAE@XZ PROC NEAR				; CTSkill::~CTSkill, COMDAT
; _this$ = ecx

; 32   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CTSkill@@6B@

; 33   : }

  00006	c3		 ret	 0
??1CTSkill@@UAE@XZ ENDP					; CTSkill::~CTSkill
_TEXT	ENDS
PUBLIC	?SetMaintain@CTSkill@@QAEXKEKEEGEKKKKEEMMM@Z	; CTSkill::SetMaintain
; Function compile flags: /Ogty
;	COMDAT ?SetMaintain@CTSkill@@QAEXKEKEEGEKKKKEEMMM@Z
_TEXT	SEGMENT
_dwAtkID$ = 8						; size = 4
_bAtkType$ = 12						; size = 1
_dwHostID$ = 16						; size = 4
_bHostType$ = 20					; size = 1
_bHit$ = 24						; size = 1
_wAtkLevel$ = 28					; size = 2
_bAttackerLevel$ = 32					; size = 1
_dwPysMinPower$ = 36					; size = 4
_dwPysMaxPower$ = 40					; size = 4
_dwMgMinPower$ = 44					; size = 4
_dwMgMaxPower$ = 48					; size = 4
_bCanSelect$ = 52					; size = 1
_bAttackCountry$ = 56					; size = 1
_fPosX$ = 60						; size = 4
_fPosY$ = 64						; size = 4
_fPosZ$ = 68						; size = 4
?SetMaintain@CTSkill@@QAEXKEKEEGEKKKKEEMMM@Z PROC NEAR	; CTSkill::SetMaintain, COMDAT
; _this$ = ecx

; 51   : 	m_dwAttackID = dwAtkID;
; 52   : 	m_bAttackType = bAtkType;

  00000	8a 54 24 08	 mov	 dl, BYTE PTR _bAtkType$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _dwAtkID$[esp-4]
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 53   : 	m_dwHostID = dwHostID;

  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _dwHostID$[esp-4]
  0000f	88 51 08	 mov	 BYTE PTR [ecx+8], dl

; 54   : 	m_bHostType = bHostType;

  00012	8a 54 24 10	 mov	 dl, BYTE PTR _bHostType$[esp-4]
  00016	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 55   : 	m_bHit = bHit;

  00019	8a 44 24 14	 mov	 al, BYTE PTR _bHit$[esp-4]
  0001d	88 51 10	 mov	 BYTE PTR [ecx+16], dl

; 56   : 	m_wAttackLevel = wAtkLevel;

  00020	66 8b 54 24 18	 mov	 dx, WORD PTR _wAtkLevel$[esp-4]
  00025	88 41 11	 mov	 BYTE PTR [ecx+17], al

; 57   : 	m_bAttackerLevel = bAttackerLevel;

  00028	8a 44 24 1c	 mov	 al, BYTE PTR _bAttackerLevel$[esp-4]
  0002c	66 89 51 12	 mov	 WORD PTR [ecx+18], dx

; 58   : 	m_dwPysMinPower = dwPysMinPower;

  00030	8b 54 24 20	 mov	 edx, DWORD PTR _dwPysMinPower$[esp-4]
  00034	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 59   : 	m_dwPysMaxPower = dwPysMaxPower;

  00037	8b 44 24 24	 mov	 eax, DWORD PTR _dwPysMaxPower$[esp-4]
  0003b	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 60   : 	m_dwMgMinPower = dwMgMinPower;

  0003e	8b 54 24 28	 mov	 edx, DWORD PTR _dwMgMinPower$[esp-4]
  00042	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 61   : 	m_dwMgMaxPower = dwMgMaxPower;

  00045	8b 44 24 2c	 mov	 eax, DWORD PTR _dwMgMaxPower$[esp-4]
  00049	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 62   : 	m_bCanSelect = bCanSelect;

  0004c	8a 54 24 30	 mov	 dl, BYTE PTR _bCanSelect$[esp-4]
  00050	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 63   : 	m_bAttackCountry = bAttackCountry;

  00053	8a 44 24 34	 mov	 al, BYTE PTR _bAttackCountry$[esp-4]
  00057	88 51 28	 mov	 BYTE PTR [ecx+40], dl

; 64   : 	m_fPosX = fPosX;

  0005a	8b 54 24 38	 mov	 edx, DWORD PTR _fPosX$[esp-4]
  0005e	88 41 29	 mov	 BYTE PTR [ecx+41], al

; 65   : 	m_fPosY = fPosY;

  00061	8b 44 24 3c	 mov	 eax, DWORD PTR _fPosY$[esp-4]
  00065	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 66   : 	m_fPosZ = fPosZ;

  00068	8b 54 24 40	 mov	 edx, DWORD PTR _fPosZ$[esp-4]
  0006c	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  0006f	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 67   : }

  00072	c2 40 00	 ret	 64			; 00000040H
?SetMaintain@CTSkill@@QAEXKEKEEGEKKKKEEMMM@Z ENDP	; CTSkill::SetMaintain
_TEXT	ENDS
PUBLIC	?GetReuseDelay@CTSkill@@QAEKEKK@Z		; CTSkill::GetReuseDelay
; Function compile flags: /Ogty
;	COMDAT ?GetReuseDelay@CTSkill@@QAEKEKK@Z
_TEXT	SEGMENT
_dwBaseDelay$ = 8					; size = 4
_bType$ = 8						; size = 1
_dwAttackSpeed$ = 12					; size = 4
_dwRate$ = 16						; size = 4
?GetReuseDelay@CTSkill@@QAEKEKK@Z PROC NEAR		; CTSkill::GetReuseDelay, COMDAT
; _this$ = ecx

; 81   : 	DWORD dwBaseDelay;
; 82   : 	switch(bType)

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR _bType$[esp-4]
  00005	83 e8 00	 sub	 eax, 0
  00008	74 15		 je	 SHORT $L152274
  0000a	48		 dec	 eax
  0000b	74 0a		 je	 SHORT $L152275
  0000d	48		 dec	 eax
  0000e	75 22		 jne	 SHORT $L153040

; 90   : 	case SDELAY_KIND:
; 91   : 		return dwAttackSpeed;

  00010	8b 44 24 08	 mov	 eax, DWORD PTR _dwAttackSpeed$[esp-4]

; 97   : }

  00014	c2 0c 00	 ret	 12			; 0000000cH
$L152275:

; 86   : 		break;
; 87   : 	case SDELAY_LOOP:
; 88   : 		dwBaseDelay = m_pTSKILL->m_dwLoopDelay;

  00017	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0001a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]

; 89   : 		break;

  0001d	eb 17		 jmp	 SHORT $L152271
$L152274:

; 83   : 	{
; 84   : 	case SDELAY_SKILL:
; 85   : 		dwBaseDelay = m_pTSKILL->m_dwReuseDelay + (m_bLevel - 1) * m_pTSKILL->m_nReuseDelayInc;

  0001f	0f b6 41 50	 movzx	 eax, BYTE PTR [ecx+80]
  00023	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00026	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00029	48		 dec	 eax
  0002a	0f af 42 50	 imul	 eax, DWORD PTR [edx+80]
  0002e	03 c1		 add	 eax, ecx
  00030	eb 04		 jmp	 SHORT $L152271
$L153040:
  00032	8b 44 24 04	 mov	 eax, DWORD PTR _dwBaseDelay$[esp-4]
$L152271:

; 92   : 	default:
; 93   : 		break;
; 94   : 	}
; 95   : 
; 96   : 	return (dwBaseDelay + dwAttackSpeed) * dwRate / 100;

  00036	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwAttackSpeed$[esp-4]
  0003a	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0003d	0f af 54 24 0c	 imul	 edx, DWORD PTR _dwRate$[esp-4]
  00042	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00047	f7 e2		 mul	 edx
  00049	8b c2		 mov	 eax, edx
  0004b	c1 e8 05	 shr	 eax, 5

; 97   : }

  0004e	c2 0c 00	 ret	 12			; 0000000cH
?GetReuseDelay@CTSkill@@QAEKEKK@Z ENDP			; CTSkill::GetReuseDelay
_TEXT	ENDS
PUBLIC	?GetRemainTick@CTSkill@@QAEKK@Z			; CTSkill::GetRemainTick
; Function compile flags: /Ogty
;	COMDAT ?GetRemainTick@CTSkill@@QAEKK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
?GetRemainTick@CTSkill@@QAEKK@Z PROC NEAR		; CTSkill::GetRemainTick, COMDAT
; _this$ = ecx

; 101  : 	if(!m_dwStartTick || (dwTick - m_dwStartTick) >= m_dwMaintainTick)

  00000	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00003	85 d2		 test	 edx, edx
  00005	74 18		 je	 SHORT $L152283
  00007	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwTick$[esp-4]
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	2b f2		 sub	 esi, edx
  00013	3b f0		 cmp	 esi, eax
  00015	5e		 pop	 esi
  00016	73 07		 jae	 SHORT $L152283

; 103  : 	else
; 104  : 		return m_dwMaintainTick - (dwTick - m_dwStartTick);

  00018	2b c1		 sub	 eax, ecx
  0001a	03 c2		 add	 eax, edx

; 105  : }

  0001c	c2 04 00	 ret	 4
$L152283:

; 102  : 		return 0;

  0001f	33 c0		 xor	 eax, eax

; 105  : }

  00021	c2 04 00	 ret	 4
?GetRemainTick@CTSkill@@QAEKK@Z ENDP			; CTSkill::GetRemainTick
_TEXT	ENDS
PUBLIC	?GetReuseRemainTick@CTSkill@@QAEKK@Z		; CTSkill::GetReuseRemainTick
; Function compile flags: /Ogty
;	COMDAT ?GetReuseRemainTick@CTSkill@@QAEKK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
?GetReuseRemainTick@CTSkill@@QAEKK@Z PROC NEAR		; CTSkill::GetReuseRemainTick, COMDAT
; _this$ = ecx

; 109  : 	if(!m_dwUseTick || (dwTick - m_dwUseTick) >= m_dwDelayTick)

  00000	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00003	85 d2		 test	 edx, edx
  00005	74 18		 je	 SHORT $L152290
  00007	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwTick$[esp-4]
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	2b f2		 sub	 esi, edx
  00013	3b f0		 cmp	 esi, eax
  00015	5e		 pop	 esi
  00016	73 07		 jae	 SHORT $L152290

; 111  : 	else
; 112  : 		return m_dwDelayTick - (dwTick - m_dwUseTick);

  00018	2b c1		 sub	 eax, ecx
  0001a	03 c2		 add	 eax, edx

; 113  : }

  0001c	c2 04 00	 ret	 4
$L152290:

; 110  : 		return 0;

  0001f	33 c0		 xor	 eax, eax

; 113  : }

  00021	c2 04 00	 ret	 4
?GetReuseRemainTick@CTSkill@@QAEKK@Z ENDP		; CTSkill::GetReuseRemainTick
_TEXT	ENDS
PUBLIC	?GetProb@CTSkill@@QAEEPAUtagTSKILLDATA@@@Z	; CTSkill::GetProb
; Function compile flags: /Ogty
;	COMDAT ?GetProb@CTSkill@@QAEEPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?GetProb@CTSkill@@QAEEPAUtagTSKILLDATA@@@Z PROC NEAR	; CTSkill::GetProb, COMDAT
; _this$ = ecx

; 116  : 	return TRUE;

  00000	b0 01		 mov	 al, 1

; 117  : }

  00002	c2 04 00	 ret	 4
?GetProb@CTSkill@@QAEEPAUtagTSKILLDATA@@@Z ENDP		; CTSkill::GetProb
_TEXT	ENDS
PUBLIC	?GetValue@CTSkill@@QAEKPAUtagTSKILLDATA@@@Z	; CTSkill::GetValue
EXTRN	?GetValue@CTSkillTemp@@QAEHPAUtagTSKILLDATA@@E@Z:NEAR ; CTSkillTemp::GetValue
; Function compile flags: /Ogty
;	COMDAT ?GetValue@CTSkill@@QAEKPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?GetValue@CTSkill@@QAEKPAUtagTSKILLDATA@@@Z PROC NEAR	; CTSkill::GetValue, COMDAT
; _this$ = ecx

; 120  : 	return m_pTSKILL->GetValue(pData, m_bLevel);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pData$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  00009	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0000c	50		 push	 eax
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 ?GetValue@CTSkillTemp@@QAEHPAUtagTSKILLDATA@@E@Z ; CTSkillTemp::GetValue

; 121  : }

  00013	c2 04 00	 ret	 4
?GetValue@CTSkill@@QAEKPAUtagTSKILLDATA@@@Z ENDP	; CTSkill::GetValue
_TEXT	ENDS
PUBLIC	?SetLoopEndTick@CTSkill@@QAEXKK@Z		; CTSkill::SetLoopEndTick
; Function compile flags: /Ogty
;	COMDAT ?SetLoopEndTick@CTSkill@@QAEXKK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
_dwRemain$ = 12						; size = 4
?SetLoopEndTick@CTSkill@@QAEXKK@Z PROC NEAR		; CTSkill::SetLoopEndTick, COMDAT
; _this$ = ecx

; 141  : 	m_dwStartTick = max(dwTick, 1);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _dwTick$[esp-4]
  00004	83 fa 01	 cmp	 edx, 1
  00007	8b c2		 mov	 eax, edx
  00009	77 05		 ja	 SHORT $L153057
  0000b	b8 01 00 00 00	 mov	 eax, 1
$L153057:
  00010	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 142  : 	m_dwMaintainTick = dwRemain;

  00013	8b 44 24 08	 mov	 eax, DWORD PTR _dwRemain$[esp-4]
  00017	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 143  : 	m_dwChargeTick = dwTick;

  0001a	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 144  : }

  0001d	c2 08 00	 ret	 8
?SetLoopEndTick@CTSkill@@QAEXKK@Z ENDP			; CTSkill::SetLoopEndTick
_TEXT	ENDS
PUBLIC	?GetMaintainTick@CTSkill@@QAEKXZ		; CTSkill::GetMaintainTick
; Function compile flags: /Ogty
;	COMDAT ?GetMaintainTick@CTSkill@@QAEKXZ
_TEXT	SEGMENT
?GetMaintainTick@CTSkill@@QAEKXZ PROC NEAR		; CTSkill::GetMaintainTick, COMDAT
; _this$ = ecx

; 148  : 	return m_pTSKILL->m_dwDuration + m_pTSKILL->m_dwDurationInc * (m_bLevel-1);

  00000	0f b6 41 50	 movzx	 eax, BYTE PTR [ecx+80]
  00004	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00007	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0000a	48		 dec	 eax
  0000b	0f af 42 28	 imul	 eax, DWORD PTR [edx+40]
  0000f	03 c1		 add	 eax, ecx

; 149  : }

  00011	c3		 ret	 0
?GetMaintainTick@CTSkill@@QAEKXZ ENDP			; CTSkill::GetMaintainTick
_TEXT	ENDS
PUBLIC	?GetID@CTSkill@@QAEGXZ				; CTSkill::GetID
EXTRN	?GetID@CTSkillTemp@@QAEGXZ:NEAR			; CTSkillTemp::GetID
; Function compile flags: /Ogty
;	COMDAT ?GetID@CTSkill@@QAEGXZ
_TEXT	SEGMENT
?GetID@CTSkill@@QAEGXZ PROC NEAR			; CTSkill::GetID, COMDAT
; _this$ = ecx

; 220  : 	return m_pTSKILL->GetID();

  00000	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00003	e9 00 00 00 00	 jmp	 ?GetID@CTSkillTemp@@QAEGXZ ; CTSkillTemp::GetID
?GetID@CTSkill@@QAEGXZ ENDP				; CTSkill::GetID
_TEXT	ENDS
PUBLIC	?CanUse@CTSkill@@QAEEK@Z			; CTSkill::CanUse
; Function compile flags: /Ogty
;	COMDAT ?CanUse@CTSkill@@QAEEK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
?CanUse@CTSkill@@QAEEK@Z PROC NEAR			; CTSkill::CanUse, COMDAT
; _this$ = ecx

; 225  : 	return !GetReuseRemainTick(dwTick);

  00000	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00003	85 d2		 test	 edx, edx
  00005	74 1d		 je	 SHORT $L153072
  00007	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR _dwTick$[esp-4]
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	2b f2		 sub	 esi, edx
  00013	3b f0		 cmp	 esi, eax
  00015	5e		 pop	 esi
  00016	73 0c		 jae	 SHORT $L153072
  00018	2b c1		 sub	 eax, ecx
  0001a	03 c2		 add	 eax, edx
  0001c	85 c0		 test	 eax, eax
  0001e	0f 94 c0	 sete	 al

; 226  : }

  00021	c2 04 00	 ret	 4

; 225  : 	return !GetReuseRemainTick(dwTick);

$L153072:
  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	0f 94 c0	 sete	 al

; 226  : }

  0002b	c2 04 00	 ret	 4
?CanUse@CTSkill@@QAEEK@Z ENDP				; CTSkill::CanUse
_TEXT	ENDS
PUBLIC	?GetNextLevel@CTSkill@@QAEEXZ			; CTSkill::GetNextLevel
; Function compile flags: /Ogty
;	COMDAT ?GetNextLevel@CTSkill@@QAEEXZ
_TEXT	SEGMENT
?GetNextLevel@CTSkill@@QAEEXZ PROC NEAR			; CTSkill::GetNextLevel, COMDAT
; _this$ = ecx

; 230  : 	return m_pTSKILL->m_bStartLevel + m_bLevel * m_pTSKILL->m_bNextLevel;

  00000	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00003	0f b6 49 50	 movzx	 ecx, BYTE PTR [ecx+80]
  00007	33 c0		 xor	 eax, eax
  00009	8a 42 56	 mov	 al, BYTE PTR [edx+86]
  0000c	0f b6 52 54	 movzx	 edx, BYTE PTR [edx+84]
  00010	0f af c1	 imul	 eax, ecx
  00013	03 c2		 add	 eax, edx

; 231  : }

  00015	c3		 ret	 0
?GetNextLevel@CTSkill@@QAEEXZ ENDP			; CTSkill::GetNextLevel
_TEXT	ENDS
PUBLIC	?IsEnd@CTSkill@@QAEEK@Z				; CTSkill::IsEnd
; Function compile flags: /Ogty
;	COMDAT ?IsEnd@CTSkill@@QAEEK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
?IsEnd@CTSkill@@QAEEK@Z PROC NEAR			; CTSkill::IsEnd, COMDAT
; _this$ = ecx

; 234  : 	if(m_dwStartTick && dwTick - m_dwStartTick >= m_dwMaintainTick)

  00000	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  00003	85 c0		 test	 eax, eax
  00005	74 10		 je	 SHORT $L152391
  00007	8b 54 24 04	 mov	 edx, DWORD PTR _dwTick$[esp-4]
  0000b	2b d0		 sub	 edx, eax
  0000d	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  00010	72 05		 jb	 SHORT $L152391

; 235  : 		return TRUE;

  00012	b0 01		 mov	 al, 1

; 238  : }

  00014	c2 04 00	 ret	 4
$L152391:

; 236  : 	else
; 237  : 		return FALSE;

  00017	32 c0		 xor	 al, al

; 238  : }

  00019	c2 04 00	 ret	 4
?IsEnd@CTSkill@@QAEEK@Z ENDP				; CTSkill::IsEnd
_TEXT	ENDS
PUBLIC	?GetNextSkillPoint@CTSkill@@QAEEXZ		; CTSkill::GetNextSkillPoint
EXTRN	?GetNeedSkillPoint@CTSkillTemp@@QAEEE@Z:NEAR	; CTSkillTemp::GetNeedSkillPoint
; Function compile flags: /Ogty
;	COMDAT ?GetNextSkillPoint@CTSkill@@QAEEXZ
_TEXT	SEGMENT
?GetNextSkillPoint@CTSkill@@QAEEXZ PROC NEAR		; CTSkill::GetNextSkillPoint, COMDAT
; _this$ = ecx

; 265  : 	return m_pTSKILL->GetNeedSkillPoint(m_bLevel + 1);

  00000	33 c0		 xor	 eax, eax
  00002	8a 41 50	 mov	 al, BYTE PTR [ecx+80]
  00005	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00008	fe c0		 inc	 al
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?GetNeedSkillPoint@CTSkillTemp@@QAEEE@Z ; CTSkillTemp::GetNeedSkillPoint

; 266  : }

  00010	c3		 ret	 0
?GetNextSkillPoint@CTSkill@@QAEEXZ ENDP			; CTSkill::GetNextSkillPoint
_TEXT	ENDS
PUBLIC	?GetUsedSkillPoint@CTSkill@@QAEGXZ		; CTSkill::GetUsedSkillPoint
; Function compile flags: /Ogty
;	COMDAT ?GetUsedSkillPoint@CTSkill@@QAEGXZ
_TEXT	SEGMENT
?GetUsedSkillPoint@CTSkill@@QAEGXZ PROC NEAR		; CTSkill::GetUsedSkillPoint, COMDAT
; _this$ = ecx

; 269  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 270  : 	WORD wTotal = 0;
; 271  : 	for(BYTE i=0; i<m_bLevel; i++)

  00004	8a 46 50	 mov	 al, BYTE PTR [esi+80]
  00007	57		 push	 edi
  00008	33 ff		 xor	 edi, edi
  0000a	32 db		 xor	 bl, bl
  0000c	84 c0		 test	 al, al
  0000e	76 16		 jbe	 SHORT $L153089
$L152420:

; 272  : 		wTotal += m_pTSKILL->GetNeedSkillPoint(i+1);

  00010	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00013	fe c3		 inc	 bl
  00015	53		 push	 ebx
  00016	e8 00 00 00 00	 call	 ?GetNeedSkillPoint@CTSkillTemp@@QAEEE@Z ; CTSkillTemp::GetNeedSkillPoint
  0001b	66 0f b6 c0	 movzx	 ax, al
  0001f	03 f8		 add	 edi, eax
  00021	3a 5e 50	 cmp	 bl, BYTE PTR [esi+80]
  00024	72 ea		 jb	 SHORT $L152420
$L153089:

; 273  : 
; 274  : 	return wTotal;

  00026	66 8b c7	 mov	 ax, di
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 275  : }

  0002c	c3		 ret	 0
?GetUsedSkillPoint@CTSkill@@QAEGXZ ENDP			; CTSkill::GetUsedSkillPoint
_TEXT	ENDS
PUBLIC	?CheckParentSkill@CTSkill@@QAEEE@Z		; CTSkill::CheckParentSkill
EXTRN	?CheckParentSkill@CTSkillTemp@@QAEEEE@Z:NEAR	; CTSkillTemp::CheckParentSkill
; Function compile flags: /Ogty
;	COMDAT ?CheckParentSkill@CTSkill@@QAEEE@Z
_TEXT	SEGMENT
_bParentLevel$ = 8					; size = 1
?CheckParentSkill@CTSkill@@QAEEE@Z PROC NEAR		; CTSkill::CheckParentSkill, COMDAT
; _this$ = ecx

; 279  : 	return m_pTSKILL->CheckParentSkill(m_bLevel + 1, bParentLevel);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _bParentLevel$[esp-4]
  00004	33 d2		 xor	 edx, edx
  00006	8a 51 50	 mov	 dl, BYTE PTR [ecx+80]
  00009	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0000c	fe c2		 inc	 dl
  0000e	50		 push	 eax
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ?CheckParentSkill@CTSkillTemp@@QAEEEE@Z ; CTSkillTemp::CheckParentSkill

; 280  : }

  00015	c2 04 00	 ret	 4
?CheckParentSkill@CTSkill@@QAEEE@Z ENDP			; CTSkill::CheckParentSkill
_TEXT	ENDS
PUBLIC	?size@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEIXZ ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::size
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?size@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	75 03		 jne	 SHORT $L153096
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L153096:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	2b c2		 sub	 eax, edx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::size
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAV012@H@Z ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+=
; Function compile flags: /Ogty
;	COMDAT ??Yiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	8b c1		 mov	 eax, ecx

; 256  : 			this->_Myptr += _Off;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0000d	01 10		 add	 DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

  0000f	c2 04 00	 ret	 4
??Yiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEABQAUtagTSKILLDATA@@XZ ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::operator*
; Function compile flags: /Ogty
;	COMDAT ??Dconst_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEABQAUtagTSKILLDATA@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEABQAUtagTSKILLDATA@@XZ PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEABQAUtagTSKILLDATA@@XZ ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::const_iterator
; Function compile flags: /Ogty
;	COMDAT ??0const_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	8b c1		 mov	 eax, ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00008	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	??$_Pow_int@M@@YAMMH@Z				; _Pow_int<float>
;	COMDAT __real@3f800000
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\math.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
??$_Pow_int@M@@YAMMH@Z PROC NEAR			; _Pow_int<float>, COMDAT

; 518  :         if (_Y >= 0)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Y$[esp-4]
  00004	85 c9		 test	 ecx, ecx

; 519  :                 _N = _Y;

  00006	8b c1		 mov	 eax, ecx

; 520  :         else

  00008	7d 02		 jge	 SHORT $L151183

; 521  :                 _N = -_Y;

  0000a	f7 d8		 neg	 eax
$L151183:

; 522  :         for (_Ty _Z = _Ty(1); ; _X *= _X)

  0000c	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3f800000
  00012	d9 44 24 04	 fld	 DWORD PTR __X$[esp-4]
$L151185:

; 523  :                 {if ((_N & 1) != 0)

  00016	a8 01		 test	 al, 1
  00018	74 06		 je	 SHORT $L151188

; 524  :                         _Z *= _X;

  0001a	d9 c9		 fxch	 ST(1)
  0001c	d8 c9		 fmul	 ST(0), ST(1)
  0001e	d9 c9		 fxch	 ST(1)
$L151188:

; 525  :                 if ((_N >>= 1) == 0)

  00020	d1 e8		 shr	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 06		 je	 SHORT $L153114
  00026	d9 c0		 fld	 ST(0)
  00028	de c9		 fmulp	 ST(1), ST(0)
  0002a	eb ea		 jmp	 SHORT $L151185
$L153114:

; 526  :                         return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

  0002c	85 c9		 test	 ecx, ecx
  0002e	dd d8		 fstp	 ST(0)
  00030	7d 06		 jge	 SHORT $L153111
  00032	d8 3d 00 00 00
	00		 fdivr	 DWORD PTR __real@3f800000
$L153111:
  00038	c3		 ret	 0
??$_Pow_int@M@@YAMMH@Z ENDP				; _Pow_int<float>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCTSkill@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTSkill@@UAEPAXI@Z PROC NEAR			; CTSkill::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	f6 44 24 04 01	 test	 BYTE PTR ___flags$[esp-4], 1
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CTSkill@@6B@
  0000e	74 09		 je	 SHORT $L153123
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$L153123:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	c2 04 00	 ret	 4
??_GCTSkill@@UAEPAXI@Z ENDP				; CTSkill::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Use@CTSkill@@QAEXEKKK@Z			; CTSkill::Use
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tmapsvr\tskill.cpp
;	COMDAT ?Use@CTSkill@@QAEXEKKK@Z
_TEXT	SEGMENT
_dwBaseDelay$153130 = 8					; size = 4
_bType$ = 8						; size = 1
_dwTick$ = 12						; size = 4
_dwAttackSpeed$ = 16					; size = 4
_dwRate$ = 20						; size = 4
?Use@CTSkill@@QAEXEKKK@Z PROC NEAR			; CTSkill::Use, COMDAT
; _this$ = ecx

; 71   : 	DWORD dwDelay = GetReuseDelay(bType, dwAttackSpeed, dwRate);

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR _bType$[esp-4]
  00005	83 e8 00	 sub	 eax, 0
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	74 14		 je	 SHORT $L153133
  0000c	48		 dec	 eax
  0000d	74 09		 je	 SHORT $L153134
  0000f	48		 dec	 eax
  00010	75 21		 jne	 SHORT $L153144
  00012	8b 54 24 14	 mov	 edx, DWORD PTR _dwAttackSpeed$[esp+4]
  00016	eb 34		 jmp	 SHORT $L153129
$L153134:
  00018	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0001e	eb 17		 jmp	 SHORT $L153132
$L153133:
  00020	0f b6 41 50	 movzx	 eax, BYTE PTR [ecx+80]
  00024	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00027	8b 72 2c	 mov	 esi, DWORD PTR [edx+44]
  0002a	48		 dec	 eax
  0002b	0f af 42 50	 imul	 eax, DWORD PTR [edx+80]
  0002f	03 c6		 add	 eax, esi
  00031	eb 04		 jmp	 SHORT $L153132
$L153144:
  00033	8b 44 24 0c	 mov	 eax, DWORD PTR _dwBaseDelay$153130[esp+4]
$L153132:
  00037	8b 54 24 14	 mov	 edx, DWORD PTR _dwAttackSpeed$[esp+4]
  0003b	03 d0		 add	 edx, eax
  0003d	0f af 54 24 18	 imul	 edx, DWORD PTR _dwRate$[esp+4]
  00042	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00047	f7 e2		 mul	 edx
  00049	c1 ea 05	 shr	 edx, 5
$L153129:

; 72   : 	if(GetReuseRemainTick(dwTick) < dwDelay)

  0004c	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0004f	85 f6		 test	 esi, esi
  00051	8b 7c 24 10	 mov	 edi, DWORD PTR _dwTick$[esp+4]
  00055	74 13		 je	 SHORT $L153141
  00057	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0005a	53		 push	 ebx
  0005b	8b df		 mov	 ebx, edi
  0005d	2b de		 sub	 ebx, esi
  0005f	3b d8		 cmp	 ebx, eax
  00061	5b		 pop	 ebx
  00062	73 06		 jae	 SHORT $L153141
  00064	2b c7		 sub	 eax, edi
  00066	03 c6		 add	 eax, esi
  00068	eb 02		 jmp	 SHORT $L153142
$L153141:
  0006a	33 c0		 xor	 eax, eax
$L153142:
  0006c	3b c2		 cmp	 eax, edx
  0006e	73 06		 jae	 SHORT $L152262

; 73   : 	{
; 74   : 		m_dwUseTick = dwTick;

  00070	89 79 44	 mov	 DWORD PTR [ecx+68], edi

; 75   : 		m_dwDelayTick = dwDelay;

  00073	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$L152262:
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 76   : 	}
; 77   : }

  00078	c2 10 00	 ret	 16			; 00000010H
?Use@CTSkill@@QAEXEKKK@Z ENDP				; CTSkill::Use
_TEXT	ENDS
PUBLIC	?SetEndTick@CTSkill@@QAEXK@Z			; CTSkill::SetEndTick
; Function compile flags: /Ogty
;	COMDAT ?SetEndTick@CTSkill@@QAEXK@Z
_TEXT	SEGMENT
_dwTick$ = 8						; size = 4
?SetEndTick@CTSkill@@QAEXK@Z PROC NEAR			; CTSkill::SetEndTick, COMDAT
; _this$ = ecx

; 134  : 	DWORD dwRemainTick = GetMaintainTick();

  00000	0f b6 41 50	 movzx	 eax, BYTE PTR [ecx+80]
  00004	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00007	48		 dec	 eax
  00008	0f af 42 28	 imul	 eax, DWORD PTR [edx+40]
  0000c	56		 push	 esi
  0000d	03 42 24	 add	 eax, DWORD PTR [edx+36]

; 135  : 	m_dwStartTick = dwRemainTick ? max(dwTick, 1) : 0;

  00010	8b 74 24 08	 mov	 esi, DWORD PTR _dwTick$[esp]
  00014	74 26		 je	 SHORT $L153150
  00016	83 fe 01	 cmp	 esi, 1
  00019	76 0f		 jbe	 SHORT $L153148
  0001b	8b d6		 mov	 edx, esi

; 136  : 	m_dwMaintainTick = dwRemainTick;
; 137  : 	m_dwChargeTick = dwTick;

  0001d	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00020	89 51 48	 mov	 DWORD PTR [ecx+72], edx
  00023	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00026	5e		 pop	 esi

; 138  : }

  00027	c2 04 00	 ret	 4
$L153148:

; 135  : 	m_dwStartTick = dwRemainTick ? max(dwTick, 1) : 0;

  0002a	ba 01 00 00 00	 mov	 edx, 1

; 136  : 	m_dwMaintainTick = dwRemainTick;
; 137  : 	m_dwChargeTick = dwTick;

  0002f	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00032	89 51 48	 mov	 DWORD PTR [ecx+72], edx
  00035	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00038	5e		 pop	 esi

; 138  : }

  00039	c2 04 00	 ret	 4
$L153150:

; 135  : 	m_dwStartTick = dwRemainTick ? max(dwTick, 1) : 0;

  0003c	33 d2		 xor	 edx, edx

; 136  : 	m_dwMaintainTick = dwRemainTick;
; 137  : 	m_dwChargeTick = dwTick;

  0003e	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00041	89 51 48	 mov	 DWORD PTR [ecx+72], edx
  00044	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00047	5e		 pop	 esi

; 138  : }

  00048	c2 04 00	 ret	 4
?SetEndTick@CTSkill@@QAEXK@Z ENDP			; CTSkill::SetEndTick
_TEXT	ENDS
PUBLIC	??Diterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEAAPAUtagTSKILLDATA@@XZ ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator*
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEAAPAUtagTSKILLDATA@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEAAPAUtagTSKILLDATA@@XZ PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBEAAPAUtagTSKILLDATA@@XZ ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBE?AV012@H@Z ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+
; Function compile flags: /Ogty
;	COMDAT ??Hiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Off$[esp-4]
  00006	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 10		 mov	 DWORD PTR [eax], edx

; 264  : 			}

  0000f	c2 08 00	 ret	 8
??Hiterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::iterator
; Function compile flags: /Ogty
;	COMDAT ??0iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00008	c2 04 00	 ret	 4
??0iterator@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE@PAPAUtagTSKILLDATA@@@Z ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?pow@@YAMMH@Z					; pow
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMH@Z PROC NEAR					; pow, COMDAT

; 573  :         {return (_Pow_int(_X, _Y)); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Y$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __X$[esp-4]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ??$_Pow_int@M@@YAMMH@Z	; _Pow_int<float>
  0000f	83 c4 08	 add	 esp, 8
  00012	c3		 ret	 0
?pow@@YAMMH@Z ENDP					; pow
_TEXT	ENDS
PUBLIC	__real@3c23d70a
PUBLIC	__real@4f800000
PUBLIC	?GetRequiredHP@CTSkill@@QAEKK@Z			; CTSkill::GetRequiredHP
EXTRN	__ftol2:NEAR
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tmapsvr\tskill.cpp
CONST	ENDS
;	COMDAT ?GetRequiredHP@CTSkill@@QAEKK@Z
_TEXT	SEGMENT
tv189 = 8						; size = 4
_dwMaxHP$ = 8						; size = 4
?GetRequiredHP@CTSkill@@QAEKK@Z PROC NEAR		; CTSkill::GetRequiredHP, COMDAT
; _this$ = ecx

; 185  : {

  00000	56		 push	 esi

; 188  : 	switch(m_pTSKILL->m_bUseHPType)

  00001	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
  00004	0f b6 56 48	 movzx	 edx, BYTE PTR [esi+72]
  00008	33 c0		 xor	 eax, eax
  0000a	4a		 dec	 edx
  0000b	74 1b		 je	 SHORT $L152363
  0000d	4a		 dec	 edx
  0000e	75 57		 jne	 SHORT $L152360

; 192  : 		break;
; 193  : 	case 2:
; 194  : 		dwHP = dwMaxHP * m_pTSKILL->m_dwUseHP / 100;

  00010	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00013	0f af 4c 24 08	 imul	 ecx, DWORD PTR _dwMaxHP$[esp]
  00018	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0001d	f7 e1		 mul	 ecx
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 05	 shr	 eax, 5
  00024	5e		 pop	 esi

; 195  : 		break;
; 196  : 	}
; 197  : 
; 198  : 	return dwHP;
; 199  : }

  00025	c2 04 00	 ret	 4
$L152363:

; 186  : 	DWORD dwHP = 0;
; 187  : 	FLOAT fRate = pow(m_pTSKILL->m_f1stRateX, int(m_pTSKILL->m_bStartLevel)+(m_bLevel-1)*m_pTSKILL->m_bNextLevel)/100;

  00028	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]

; 189  : 	{
; 190  : 	case 1:
; 191  : 		dwHP = DWORD(m_pTSKILL->m_dwUseHP * fRate);

  0002b	0f b6 51 50	 movzx	 edx, BYTE PTR [ecx+80]
  0002f	0f b6 48 56	 movzx	 ecx, BYTE PTR [eax+86]
  00033	4a		 dec	 edx
  00034	0f af d1	 imul	 edx, ecx
  00037	0f b6 48 54	 movzx	 ecx, BYTE PTR [eax+84]
  0003b	03 d1		 add	 edx, ecx
  0003d	52		 push	 edx
  0003e	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ??$_Pow_int@M@@YAMMH@Z	; _Pow_int<float>
  00047	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0004a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00050	83 c4 08	 add	 esp, 8
  00053	85 c0		 test	 eax, eax
  00055	db 46 44	 fild	 DWORD PTR [esi+68]
  00058	7d 06		 jge	 SHORT $L153187
  0005a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L153187:
  00060	de c9		 fmulp	 ST(1), ST(0)
  00062	e8 00 00 00 00	 call	 __ftol2
$L152360:
  00067	5e		 pop	 esi

; 195  : 		break;
; 196  : 	}
; 197  : 
; 198  : 	return dwHP;
; 199  : }

  00068	c2 04 00	 ret	 4
?GetRequiredHP@CTSkill@@QAEKK@Z ENDP			; CTSkill::GetRequiredHP
_TEXT	ENDS
PUBLIC	?GetRequiredMP@CTSkill@@QAEKK@Z			; CTSkill::GetRequiredMP
; Function compile flags: /Ogty
;	COMDAT ?GetRequiredMP@CTSkill@@QAEKK@Z
_TEXT	SEGMENT
tv189 = 8						; size = 4
_dwMaxMP$ = 8						; size = 4
?GetRequiredMP@CTSkill@@QAEKK@Z PROC NEAR		; CTSkill::GetRequiredMP, COMDAT
; _this$ = ecx

; 202  : {

  00000	56		 push	 esi

; 205  : 	switch(m_pTSKILL->m_bUseMPType)

  00001	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
  00004	0f b6 56 40	 movzx	 edx, BYTE PTR [esi+64]
  00008	33 c0		 xor	 eax, eax
  0000a	4a		 dec	 edx
  0000b	74 1b		 je	 SHORT $L152375
  0000d	4a		 dec	 edx
  0000e	75 57		 jne	 SHORT $L152372

; 209  : 		break;
; 210  : 	case 2:
; 211  : 		dwMP = dwMaxMP * m_pTSKILL->m_dwUseMP / 100;

  00010	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00013	0f af 4c 24 08	 imul	 ecx, DWORD PTR _dwMaxMP$[esp]
  00018	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0001d	f7 e1		 mul	 ecx
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 05	 shr	 eax, 5
  00024	5e		 pop	 esi

; 212  : 		break;
; 213  : 	}
; 214  : 
; 215  : 	return dwMP;
; 216  : }

  00025	c2 04 00	 ret	 4
$L152375:

; 203  : 	DWORD dwMP = 0;
; 204  : 	FLOAT fRate = pow(m_pTSKILL->m_f1stRateX, int(m_pTSKILL->m_bStartLevel)+(m_bLevel-1)*m_pTSKILL->m_bNextLevel)/100;

  00028	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]

; 206  : 	{
; 207  : 	case 1:
; 208  : 		dwMP = DWORD(m_pTSKILL->m_dwUseMP * fRate);

  0002b	0f b6 51 50	 movzx	 edx, BYTE PTR [ecx+80]
  0002f	0f b6 48 56	 movzx	 ecx, BYTE PTR [eax+86]
  00033	4a		 dec	 edx
  00034	0f af d1	 imul	 edx, ecx
  00037	0f b6 48 54	 movzx	 ecx, BYTE PTR [eax+84]
  0003b	03 d1		 add	 edx, ecx
  0003d	52		 push	 edx
  0003e	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ??$_Pow_int@M@@YAMMH@Z	; _Pow_int<float>
  00047	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0004a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c23d70a
  00050	83 c4 08	 add	 esp, 8
  00053	85 c0		 test	 eax, eax
  00055	db 46 3c	 fild	 DWORD PTR [esi+60]
  00058	7d 06		 jge	 SHORT $L153197
  0005a	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L153197:
  00060	de c9		 fmulp	 ST(1), ST(0)
  00062	e8 00 00 00 00	 call	 __ftol2
$L152372:
  00067	5e		 pop	 esi

; 212  : 		break;
; 213  : 	}
; 214  : 
; 215  : 	return dwMP;
; 216  : }

  00068	c2 04 00	 ret	 4
?GetRequiredMP@CTSkill@@QAEKK@Z ENDP			; CTSkill::GetRequiredMP
_TEXT	ENDS
PUBLIC	?GetAggro@CTSkill@@QAEKXZ			; CTSkill::GetAggro
; Function compile flags: /Ogty
;	COMDAT ?GetAggro@CTSkill@@QAEKXZ
_TEXT	SEGMENT
tv185 = -4						; size = 4
?GetAggro@CTSkill@@QAEKXZ PROC NEAR			; CTSkill::GetAggro, COMDAT
; _this$ = ecx

; 251  : {

  00000	51		 push	 ecx

; 252  : 	if(!m_pTSKILL->m_dwAggro)

  00001	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00004	56		 push	 esi
  00005	8b 70 4c	 mov	 esi, DWORD PTR [eax+76]
  00008	85 f6		 test	 esi, esi
  0000a	75 05		 jne	 SHORT $L152407

; 253  : 		return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	5e		 pop	 esi

; 257  : }

  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
$L152407:

; 254  : 
; 255  : 	DWORD dwAggro = DWORD(m_pTSKILL->m_dwAggro * pow(m_pTSKILL->m_f1stRateX, m_pTSKILL->m_bStartLevel+(m_bLevel-1)*m_pTSKILL->m_bNextLevel)) / 100;

  00011	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]

; 256  : 	return dwAggro;

  00014	0f b6 49 50	 movzx	 ecx, BYTE PTR [ecx+80]
  00018	0f b6 50 56	 movzx	 edx, BYTE PTR [eax+86]
  0001c	49		 dec	 ecx
  0001d	0f af ca	 imul	 ecx, edx
  00020	0f b6 50 54	 movzx	 edx, BYTE PTR [eax+84]
  00024	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  00027	03 ca		 add	 ecx, edx
  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Pow_int@M@@YAMMH@Z	; _Pow_int<float>
  00030	83 c4 08	 add	 esp, 8
  00033	85 f6		 test	 esi, esi
  00035	89 74 24 04	 mov	 DWORD PTR tv185[esp+8], esi
  00039	db 44 24 04	 fild	 DWORD PTR tv185[esp+8]
  0003d	7d 06		 jge	 SHORT $L153205
  0003f	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$L153205:

; 254  : 
; 255  : 	DWORD dwAggro = DWORD(m_pTSKILL->m_dwAggro * pow(m_pTSKILL->m_f1stRateX, m_pTSKILL->m_bStartLevel+(m_bLevel-1)*m_pTSKILL->m_bNextLevel)) / 100;

  00045	de c9		 fmulp	 ST(1), ST(0)

; 256  : 	return dwAggro;

  00047	e8 00 00 00 00	 call	 __ftol2
  0004c	8b c8		 mov	 ecx, eax
  0004e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00053	f7 e1		 mul	 ecx
  00055	8b c2		 mov	 eax, edx
  00057	c1 e8 05	 shr	 eax, 5
  0005a	5e		 pop	 esi

; 257  : }

  0005b	59		 pop	 ecx
  0005c	c3		 ret	 0
?GetAggro@CTSkill@@QAEKXZ ENDP				; CTSkill::GetAggro
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::begin
; Function compile flags: /Ogty
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?begin@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::begin, COMDAT
; _this$ = ecx

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00009	c2 04 00	 ret	 4
?begin@?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::begin
_TEXT	ENDS
PUBLIC	??A?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAPAUtagTSKILLDATA@@I@Z ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::operator[]
; Function compile flags: /Ogty
;	COMDAT ??A?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAPAUtagTSKILLDATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAPAUtagTSKILLDATA@@I@Z PROC NEAR ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::operator[], COMDAT
; _this$ = ecx

; 555  : 		return (*(begin() + _Pos));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 04	 mov	 ecx, DWORD PTR __Pos$[esp-4]
  00007	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 556  : 		}

  0000a	c2 04 00	 ret	 4
??A?$vector@PAUtagTSKILLDATA@@V?$allocator@PAUtagTSKILLDATA@@@std@@@std@@QAEAAPAUtagTSKILLDATA@@I@Z ENDP ; std::vector<tagTSKILLDATA *,std::allocator<tagTSKILLDATA *> >::operator[]
_TEXT	ENDS
PUBLIC	?GetValue@CTSkill@@QAEKEE@Z			; CTSkill::GetValue
; Function compile flags: /Ogty
; File c:\users\pierr\desktop\4story - oldschool\sources\tserver\tmapsvr\tskill.cpp
;	COMDAT ?GetValue@CTSkill@@QAEKEE@Z
_TEXT	SEGMENT
tv238 = 8						; size = 4
_bType$ = 8						; size = 1
_bExec$ = 12						; size = 1
?GetValue@CTSkill@@QAEKEE@Z PROC NEAR			; CTSkill::GetValue, COMDAT
; _this$ = ecx

; 123  : {

  00000	53		 push	 ebx

; 124  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  00001	8a 5c 24 08	 mov	 bl, BYTE PTR _bType$[esp]
  00005	55		 push	 ebp
  00006	8b e9		 mov	 ebp, ecx
  00008	8b 4d 54	 mov	 ecx, DWORD PTR [ebp+84]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b b9 84 00 00
	00		 mov	 edi, DWORD PTR [ecx+132]
  00013	33 d2		 xor	 edx, edx
$L152306:
  00015	85 ff		 test	 edi, edi
  00017	74 54		 je	 SHORT $L152308
  00019	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0001f	2b c7		 sub	 eax, edi
  00021	c1 f8 02	 sar	 eax, 2
  00024	3b d0		 cmp	 edx, eax
  00026	73 45		 jae	 SHORT $L152308
  00028	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  0002e	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]

; 125  : 	{
; 126  : 		if(m_pTSKILL->m_vData[i]->m_bType == bType &&
; 127  : 			m_pTSKILL->m_vData[i]->m_bExec == bExec)

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	38 58 01	 cmp	 BYTE PTR [eax+1], bl
  00036	75 11		 jne	 SHORT $L152307
  00038	89 4c 24 14	 mov	 DWORD PTR tv238[esp+12], ecx
  0003c	8a 4c 24 18	 mov	 cl, BYTE PTR _bExec$[esp+12]
  00040	38 48 03	 cmp	 BYTE PTR [eax+3], cl
  00043	8b 4c 24 14	 mov	 ecx, DWORD PTR tv238[esp+12]
  00047	74 03		 je	 SHORT $L153440
$L152307:

; 124  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  00049	42		 inc	 edx
  0004a	eb c9		 jmp	 SHORT $L152306
$L153440:

; 128  : 			return GetValue(m_pTSKILL->m_vData[i]);

  0004c	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  00052	5f		 pop	 edi
  00053	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	5e		 pop	 esi
  00059	33 d2		 xor	 edx, edx
  0005b	8a 55 50	 mov	 dl, BYTE PTR [ebp+80]
  0005e	5d		 pop	 ebp
  0005f	5b		 pop	 ebx
  00060	89 54 24 08	 mov	 BYTE PTR _bExec$[esp-4], edx
  00064	89 44 24 04	 mov	 BYTE PTR _bType$[esp-4], eax
  00068	e9 00 00 00 00	 jmp	 ?GetValue@CTSkillTemp@@QAEHPAUtagTSKILLDATA@@E@Z ; CTSkillTemp::GetValue
$L152308:
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp

; 129  : 	}
; 130  : 	return 0;

  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx

; 131  : }

  00073	c2 08 00	 ret	 8
?GetValue@CTSkill@@QAEKEE@Z ENDP			; CTSkill::GetValue
_TEXT	ENDS
PUBLIC	?CalcAbilityValue@CTSkill@@QAEHEKE@Z		; CTSkill::CalcAbilityValue
EXTRN	?Calculate@CTSkillTemp@@QAEHEKK@Z:NEAR		; CTSkillTemp::Calculate
; Function compile flags: /Ogty
;	COMDAT ?CalcAbilityValue@CTSkill@@QAEHEKE@Z
_TEXT	SEGMENT
_bAction$ = 8						; size = 1
_dwValue$ = 12						; size = 4
_bExec$ = 16						; size = 1
?CalcAbilityValue@CTSkill@@QAEHEKE@Z PROC NEAR		; CTSkill::CalcAbilityValue, COMDAT
; _this$ = ecx

; 151  : {

  00000	53		 push	 ebx

; 152  : 	int nIncreaseValue = 0;
; 153  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  00001	8a 5c 24 08	 mov	 bl, BYTE PTR _bAction$[esp]
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	33 ed		 xor	 ebp, ebp
  0000a	8b f9		 mov	 edi, ecx
  0000c	33 f6		 xor	 esi, esi
  0000e	8b ff		 npad	 2
$L152331:
  00010	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00013	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00019	85 d2		 test	 edx, edx
  0001b	74 42		 je	 SHORT $L153625
  0001d	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  00023	2b c2		 sub	 eax, edx
  00025	c1 f8 02	 sar	 eax, 2
  00028	3b f0		 cmp	 esi, eax
  0002a	73 33		 jae	 SHORT $L153625
  0002c	8b c2		 mov	 eax, edx

; 154  : 	{
; 155  : 		if( m_pTSKILL->m_vData[i]->m_bAction == bAction &&
; 156  : 			m_pTSKILL->m_vData[i]->m_bType == SDT_ABILITY &&
; 157  : 			m_pTSKILL->m_vData[i]->m_bExec == bExec)

  0002e	8b 14 b0	 mov	 edx, DWORD PTR [eax+esi*4]
  00031	38 1a		 cmp	 BYTE PTR [edx], bl
  00033	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00036	75 24		 jne	 SHORT $L152332
  00038	80 7a 01 01	 cmp	 BYTE PTR [edx+1], 1
  0003c	75 1e		 jne	 SHORT $L152332
  0003e	8b c2		 mov	 eax, edx
  00040	8a 54 24 1c	 mov	 dl, BYTE PTR _bExec$[esp+12]
  00044	38 50 03	 cmp	 BYTE PTR [eax+3], dl
  00047	75 13		 jne	 SHORT $L152332

; 158  : 			nIncreaseValue += m_pTSKILL->Calculate(m_bLevel, i, dwValue);

  00049	8b 44 24 18	 mov	 eax, DWORD PTR _dwValue$[esp+12]
  0004d	33 d2		 xor	 edx, edx
  0004f	8a 57 50	 mov	 dl, BYTE PTR [edi+80]
  00052	50		 push	 eax
  00053	56		 push	 esi
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ?Calculate@CTSkillTemp@@QAEHEKK@Z ; CTSkillTemp::Calculate
  0005a	03 e8		 add	 ebp, eax
$L152332:

; 152  : 	int nIncreaseValue = 0;
; 153  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  0005c	46		 inc	 esi
  0005d	eb b1		 jmp	 SHORT $L152331
$L153625:
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 159  : 	}
; 160  : 	return nIncreaseValue;

  00061	8b c5		 mov	 eax, ebp
  00063	5d		 pop	 ebp
  00064	5b		 pop	 ebx

; 161  : }

  00065	c2 0c 00	 ret	 12			; 0000000cH
?CalcAbilityValue@CTSkill@@QAEHEKE@Z ENDP		; CTSkill::CalcAbilityValue
_TEXT	ENDS
PUBLIC	?CalcCure@CTSkill@@QAEHPAV1@KE@Z		; CTSkill::CalcCure
; Function compile flags: /Ogty
;	COMDAT ?CalcCure@CTSkill@@QAEHPAV1@KE@Z
_TEXT	SEGMENT
_nIncreaseValue$ = -4					; size = 4
_pSkill$ = 8						; size = 4
_dwValue$ = 12						; size = 4
_bExec$ = 16						; size = 1
?CalcCure@CTSkill@@QAEHPAV1@KE@Z PROC NEAR		; CTSkill::CalcCure, COMDAT
; _this$ = ecx

; 163  : {

  00000	51		 push	 ecx

; 164  : 	if(!pSkill)

  00001	8b 44 24 08	 mov	 eax, DWORD PTR _pSkill$[esp]
  00005	53		 push	 ebx
  00006	33 db		 xor	 ebx, ebx
  00008	3b c3		 cmp	 eax, ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	75 08		 jne	 SHORT $L152341
  0000f	5f		 pop	 edi

; 165  : 		return 0;

  00010	33 c0		 xor	 eax, eax
  00012	5b		 pop	 ebx

; 182  : }

  00013	59		 pop	 ecx
  00014	c2 0c 00	 ret	 12			; 0000000cH
$L152341:
  00017	55		 push	 ebp

; 166  : 
; 167  : 	int nIncreaseValue = 0;

  00018	89 5c 24 0c	 mov	 DWORD PTR _nIncreaseValue$[esp+16], ebx
  0001c	56		 push	 esi
  0001d	8d 49 00	 npad	 3
$L152344:

; 168  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  00020	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00023	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00029	85 d2		 test	 edx, edx
  0002b	0f 84 9d 00 00
	00		 je	 $L153872
  00031	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 02	 sar	 eax, 2
  0003c	3b d8		 cmp	 ebx, eax
  0003e	0f 83 8a 00 00
	00		 jae	 $L153872
  00044	8b c2		 mov	 eax, edx
  00046	8d 2c 9d 00 00
	00 00		 lea	 ebp, DWORD PTR [ebx*4]

; 169  : 	{
; 170  : 		if(	m_pTSKILL->m_vData[i]->m_bType == SDT_CURE &&
; 171  : 			m_pTSKILL->m_vData[i]->m_bExec == bExec)

  0004d	8b 0c 28	 mov	 ecx, DWORD PTR [eax+ebp]
  00050	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00053	03 c5		 add	 eax, ebp
  00055	80 fa 05	 cmp	 dl, 5
  00058	75 6e		 jne	 SHORT $L152345
  0005a	8a 44 24 20	 mov	 al, BYTE PTR _bExec$[esp+16]
  0005e	8b d1		 mov	 edx, ecx
  00060	38 42 03	 cmp	 BYTE PTR [edx+3], al
  00063	75 63		 jne	 SHORT $L152345

; 172  : 		{
; 173  : 			for(DWORD j=0; j<pSkill->m_pTSKILL->m_vData.size(); j++)

  00065	33 f6		 xor	 esi, esi
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L152349:
  00070	8b 4c 24 18	 mov	 ecx, DWORD PTR _pSkill$[esp+16]
  00074	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00077	8b 8a 84 00 00
	00		 mov	 ecx, DWORD PTR [edx+132]
  0007d	85 c9		 test	 ecx, ecx
  0007f	74 47		 je	 SHORT $L152345
  00081	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00087	2b c1		 sub	 eax, ecx
  00089	c1 f8 02	 sar	 eax, 2
  0008c	3b f0		 cmp	 esi, eax
  0008e	73 38		 jae	 SHORT $L152345

; 174  : 			{
; 175  : 				if(	m_pTSKILL->m_vData[i]->m_bAttr == pSkill->m_pTSKILL->m_vData[j]->m_bAttr)

  00090	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  00093	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  00099	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [edx+132]
  0009f	03 c5		 add	 eax, ebp
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  000a6	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  000a9	8b 12		 mov	 edx, DWORD PTR [edx]
  000ab	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  000ae	75 15		 jne	 SHORT $L152350

; 176  : 					nIncreaseValue += m_pTSKILL->Calculate(m_bLevel, i, dwValue);

  000b0	8b 54 24 1c	 mov	 edx, DWORD PTR _dwValue$[esp+16]
  000b4	33 c0		 xor	 eax, eax
  000b6	8a 47 50	 mov	 al, BYTE PTR [edi+80]
  000b9	52		 push	 edx
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?Calculate@CTSkillTemp@@QAEHEKK@Z ; CTSkillTemp::Calculate
  000c1	01 44 24 10	 add	 DWORD PTR _nIncreaseValue$[esp+20], eax
$L152350:

; 172  : 		{
; 173  : 			for(DWORD j=0; j<pSkill->m_pTSKILL->m_vData.size(); j++)

  000c5	46		 inc	 esi
  000c6	eb a8		 jmp	 SHORT $L152349
$L152345:

; 168  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  000c8	43		 inc	 ebx
  000c9	e9 52 ff ff ff	 jmp	 $L152344
$L153872:

; 177  : 			}
; 178  : 		}
; 179  : 	}
; 180  : 
; 181  : 	return nIncreaseValue;

  000ce	8b 44 24 10	 mov	 eax, DWORD PTR _nIncreaseValue$[esp+20]
  000d2	5e		 pop	 esi
  000d3	5d		 pop	 ebp
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx

; 182  : }

  000d6	59		 pop	 ecx
  000d7	c2 0c 00	 ret	 12			; 0000000cH
?CalcCure@CTSkill@@QAEHPAV1@KE@Z ENDP			; CTSkill::CalcCure
_TEXT	ENDS
PUBLIC	?GetBlood@CTSkill@@QAEKKE@Z			; CTSkill::GetBlood
; Function compile flags: /Ogty
;	COMDAT ?GetBlood@CTSkill@@QAEKKE@Z
_TEXT	SEGMENT
tv237 = -4						; size = 4
_dwValue$ = 8						; size = 4
_bExec$ = 12						; size = 1
?GetBlood@CTSkill@@QAEKKE@Z PROC NEAR			; CTSkill::GetBlood, COMDAT
; _this$ = ecx

; 241  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	8b e9		 mov	 ebp, ecx
  00004	8b 4d 54	 mov	 ecx, DWORD PTR [ebp+84]
  00007	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 242  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  0000f	33 f6		 xor	 esi, esi
$L152399:
  00011	85 d2		 test	 edx, edx
  00013	74 63		 je	 SHORT $L152401
  00015	8b 81 88 00 00
	00		 mov	 eax, DWORD PTR [ecx+136]
  0001b	2b c2		 sub	 eax, edx
  0001d	c1 f8 02	 sar	 eax, 2
  00020	3b f0		 cmp	 esi, eax
  00022	73 54		 jae	 SHORT $L152401
  00024	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]

; 243  : 	{
; 244  : 		if(m_pTSKILL->m_vData[i]->m_bType == SDT_ABILITY &&
; 245  : 			m_pTSKILL->m_vData[i]->m_bExec == bExec)

  0002a	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]
  0002d	80 7f 01 01	 cmp	 BYTE PTR [edi+1], 1
  00031	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00034	75 13		 jne	 SHORT $L152400
  00036	89 4c 24 0c	 mov	 DWORD PTR tv237[esp+16], ecx
  0003a	8a 4c 24 18	 mov	 cl, BYTE PTR _bExec$[esp+12]
  0003e	8b c7		 mov	 eax, edi
  00040	38 48 03	 cmp	 BYTE PTR [eax+3], cl
  00043	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv237[esp+16]
  00047	74 03		 je	 SHORT $L154000
$L152400:

; 242  : 	for(DWORD i=0; i<m_pTSKILL->m_vData.size(); i++)

  00049	46		 inc	 esi
  0004a	eb c5		 jmp	 SHORT $L152399
$L154000:

; 246  : 			return (DWORD)max(m_pTSKILL->Calculate(m_bLevel, i, dwValue), 0);

  0004c	8b 7c 24 14	 mov	 edi, DWORD PTR _dwValue$[esp+12]
  00050	33 d2		 xor	 edx, edx
  00052	8a 55 50	 mov	 dl, BYTE PTR [ebp+80]
  00055	57		 push	 edi
  00056	56		 push	 esi
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 ?Calculate@CTSkillTemp@@QAEHEKK@Z ; CTSkillTemp::Calculate
  0005d	85 c0		 test	 eax, eax
  0005f	7e 17		 jle	 SHORT $L152401
  00061	8b 4d 54	 mov	 ecx, DWORD PTR [ebp+84]
  00064	33 c0		 xor	 eax, eax
  00066	8a 45 50	 mov	 al, BYTE PTR [ebp+80]
  00069	57		 push	 edi
  0006a	56		 push	 esi
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?Calculate@CTSkillTemp@@QAEHEKK@Z ; CTSkillTemp::Calculate
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp

; 249  : }

  00074	59		 pop	 ecx
  00075	c2 08 00	 ret	 8
$L152401:
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 247  : 	}
; 248  : 	return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	5d		 pop	 ebp

; 249  : }

  0007d	59		 pop	 ecx
  0007e	c2 08 00	 ret	 8
?GetBlood@CTSkill@@QAEKKE@Z ENDP			; CTSkill::GetBlood
_TEXT	ENDS
PUBLIC	?GetCountMultiAttack@CTSkill@@QAEEXZ		; CTSkill::GetCountMultiAttack
; Function compile flags: /Ogty
;	COMDAT ?GetCountMultiAttack@CTSkill@@QAEEXZ
_TEXT	SEGMENT
?GetCountMultiAttack@CTSkill@@QAEEXZ PROC NEAR		; CTSkill::GetCountMultiAttack, COMDAT
; _this$ = ecx

; 260  : 	return CalcAbilityValue(SA_ONCE, 1, MTYPE_EFC);

  00000	6a 24		 push	 36			; 00000024H
  00002	6a 01		 push	 1
  00004	6a 00		 push	 0
  00006	e8 00 00 00 00	 call	 ?CalcAbilityValue@CTSkill@@QAEHEKE@Z ; CTSkill::CalcAbilityValue

; 261  : }

  0000b	c3		 ret	 0
?GetCountMultiAttack@CTSkill@@QAEEXZ ENDP		; CTSkill::GetCountMultiAttack
_TEXT	ENDS
END
